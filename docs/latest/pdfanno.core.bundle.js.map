{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6*","webpack:///./src/core/src/utils/relation.js","webpack:///webpack/bootstrap 02b50d569d092c71ef71?4eb5*","webpack:///./src/shared/coords.js?7ba8*","webpack:///./src/shared/util.js?a13c*","webpack:///./node_modules/anno-ui/src/utils/index.js?193f*","webpack:///./node_modules/css-loader/lib/css-base.js?159f*","webpack:///./node_modules/style-loader/addStyles.js?7e36*","webpack:///./node_modules/toml/index.js?a7ec*","webpack:///./node_modules/toml/lib/parser.js?267a*","webpack:///./node_modules/toml/lib/compiler.js?0848*","webpack:///./src/core/src/annotation/span.js","webpack:///./src/core/src/annotation/abstract.js","webpack:///./src/core/src/render/renderKnob.js","webpack:///./src/core/src/annotation/relation.js","webpack:///./node_modules/events/events.js","webpack:///./src/core/src/UI/utils.js","webpack:///./src/core/src/render/appendChild.js","webpack:///./src/core/src/utils/color.js","webpack:///./src/core/src/version.js","webpack:///./src/core/src/utils/setAttributes.js","webpack:///./src/core/src/utils/event.js","webpack:///./src/core/src/utils/textInput.js","webpack:///./src/core/src/annotation/rect.js","webpack:///./src/core/index.js","webpack:///./src/core/index.css?a5d4","webpack:///./src/core/index.css","webpack:///./src/core/src/PDFAnnoCore.js","webpack:///./src/core/src/UI/index.js","webpack:///./src/core/src/UI/span.js","webpack:///./src/core/src/render/renderRect.js","webpack:///./src/core/src/render/renderSpan.js","webpack:///./package.json","webpack:///./src/core/src/render/renderText.js","webpack:///./src/core/src/render/renderRelation.js","webpack:///./src/core/src/UI/relation.js","webpack:///./src/core/src/UI/view.js","webpack:///./src/core/src/annotation/container.js","webpack:///./src/core/src/utils/tomlString.js"],"names":[],"mappings":"AAAA,cACA,2BACA,uCACA,sCACA,WACA,MACA,6CAEA,kBACA,GAAC,yCCyCD,WALA,WAFA,WADA,kBDhCA,kBETA,cAMA,IACA,iBAGA,mBACA,CACA,IACA,aAIA,mCAGA,aAGA,OACA,OAIA,OAzBA,YA4BA,MAGA,uBACA,GACA,kCACA,CACA,gBACA,cAGA,OAGA,iBACA,YACA,qBAA2B,UAA0B,UACrD,YAAiC,CAAe,QAChD,EAEA,aADA,QAIA,mBAAsD,wCAA+D,SAGrH,MAGA,2CCfA,YAEA,2CAEA,8CACA,UAAc,qBACd,IACA,QAIA,KAtDA,WAEA,OAEA,IAEA,aAEA,kBACA,SAEA,WAAU,cACV,IAIA,EAnBA,IAoBA,aAEA,OAEA,MAIA,IAGA,mBADA,WAKA,EAjCA,IAwDA,UAEA,+CAEA,gBACA,0BAGA,MACA,cA/BA,QAKA,MAIA,uCCzCA,aACA,OACA,8BAIA,EAVA,IAWA,aACA,4BACA,iBACA,kCACA,gBAMA,EAnBA,IAoBA,UACA,wBACA,mBACA,UACA,mBACA,oBACA,KAEA,MADA,SACK,EACL,iCCuGA,IACA,aAGA,CAGA,QAGA,qEAEA,aACA,aAAmB,EAAe,IAClC,gBAEA,aACA,QA+BA,cClLA,CACA,oBACA,OAGA,GAwCA,4BAvCA,aACA,KAAgB,SAAiB,OACjC,MACA,UACA,yBAAwC,SAExC,cAGA,kBACA,GAGA,mBACA,CACA,gCACA,kBACA,KAAgB,SAAiB,OACjC,cACA,GACA,qBAEA,eAAY,MAAoB,WAChC,OAKA,gCACA,YACA,KAEA,mCAEA,OAEA,QACA,CACA,iBC7CA,CA0DA,eACA,WAAe,MAAmB,WAClC,OACA,WACA,SACA,GACA,iBAAiB,YAA2B,OAC5C,iBAEA,UAAQ,eAAuB,OAC/B,qBAEA,YAAG,KACH,WACA,KAAiB,YAAuB,OACxC,eAEA,sBAA2B,eAC3B,QACA,CACA,EAEA,aACA,WACA,KACA,KAAe,MAAiB,WAChC,OACA,SACA,OACA,OACA,OACA,MAAc,cACd,aACA,gBAGA,qBAHgC,WAEhC,KAEA,CACA,SAEA,eACA,OACA,iBACA,MAEA,uBAEA,+BAEA,eAEA,kCALG,cAMD,gBACF,wBAEA,oCAEA,4EAEA,aACA,cACA,uBACA,WACA,iBAEA,GAEA,aACA,8BACA,SAGA,cAFA,WACA,SAGA,aACA,8BACA,QAGA,aAFA,aACA,SAGA,eACA,SAEA,iBACA,OACA,YACA,eACA,sBACA,YAAE,QACF,WACA,wBACA,wCACA,wCACA,yBACA,2BACA,cACA,oBACA,CACA,OACA,4BACA,KAEA,MACA,cACA,oBACA,CACA,IAGA,SAEA,iBACA,MACA,sDACA,UACA,SACA,IACA,KAEA,IACA,EAWA,mBACA,cAEA,SACA,gCACE,WACF,gBACA,sBACA,+BACA,QACA,wBAEA,QAEA,cACA,EAEA,eACA,SACA,QAGA,2BAGA,aACA,wBACE,cACF,QACA,4BAEA,mCACA,kBACA,EAEA,eACA,SACA,QAIA,iBAAuD,6GAGvD,0BAA6B,MAE7B,iBAEA,gBAGA,0BACA,mBAjPA,MACA,gBACA,IACA,oBACA,CAEA,6CADA,aAEA,CACA,gBACA,qDACA,cACA,iBACA,6DACA,EACA,KACA,OACA,OAEA,uBACA,+BACA,iDAGA,qEAGA,iDAGA,iDAEA,gBACA,WAEA,mBACA,WACA,KAAgB,MAAmB,WACnC,OACA,WACA,MACA,SACA,OACA,MACA,OACA,KACA,MACA,aAAgB,MAAsB,OACtC,SACA,gBACA,WAAkB,YAA2B,OAC7C,MACA,sBACA,GAEA,CACA,GA6HA,gBACA,OAEA,uBACA,OACA,+BACA,KACA,CAAC,0BC/LD,QACA,YAEA,UACA,kBACA,iBACA,qBACA,UACA,gBCRA,oBAOA,wBAOA,MACA,eACA,gBACA,aACA,cACA,YAEA,mBACA,aAEA,cAGA,aA+JA,cACA,IAEA,aACA,cACA,MAcA,cACA,CA8BA,MATA,UACA,UACA,KAAkC,iBAElC,2BAxBA,OAEA,MAA0B,IAAY,IACtC,QACA,UACA,aAAkC,UAClC,gBACA,IACW,mCACX,gBACA,gBACA,IAEA,cACA,WAGA,UAEA,CAMA,UAGA,QAGA,cACA,CAEA,QACA,QACA,SAGA,OACA,QAEA,aA6EA,SAEA,UACA,IAEA,MACA,iBACA,UAGA,WACA,OACA,KACA,IACA,UACA,UAEA,IASA,MARA,UACA,OAEA,MAEA,UAAwB,YAExB,WAGA,aACA,iBAEA,UACA,IAEA,MACA,iBACA,UAGA,WACA,OACA,KACA,IACA,UACA,UAEA,OACA,OAkDA,KAEA,eAnDA,WACA,OACA,KACA,IACA,UACA,UAEA,cACA,OACA,KACA,IACA,UACA,UAEA,cACA,MACA,KACA,IACA,YACA,UACA,UAGA,QAEA,MACA,WAEA,KACA,QAIA,KAEA,SALA,YAEA,IAIA,KACA,MAEA,IACA,KACA,MAEA,IACA,KACA,MAGA,eAIA,IACA,OACA,KACA,IACA,YACA,UACA,UAGA,QAEA,gBACA,MACA,KACA,IACA,YACA,UACA,UAGA,QAEA,MACA,WAEA,KACA,QAIA,KAEA,SALA,MAEA,IAIA,KACA,MAEA,KACA,WAEA,IAEA,CAGA,aAHwB,YAExB,WAGA,aACA,IAEA,WACA,IAGA,qBACA,UAGA,WACA,IACA,WACA,IACA,WACA,IACA,WAKA,aAAwB,YAGxB,YAEA,aACA,eAEA,UACA,IAEA,MACA,iBACA,UAGA,UACA,KACA,uBACA,KAEA,OACA,KAAoC,QAEpC,cACA,OACA,GACA,KACA,KACA,OACA,IACA,WAEA,KACA,KACA,OAEA,MACA,KAEA,MACA,QAgBA,KAEA,SAjBA,eACA,WAEA,OACA,KAAwC,QAExC,OACA,QAIA,KAGA,SANA,MAEA,MAQA,UACA,QACA,KACA,KACA,OACA,IACA,WAEA,KACA,KACA,OAEA,MACA,KAEA,MACA,QAgBA,KAGA,SAlBA,eACA,WAEA,OACA,KAA0C,QAE1C,OACA,QAIA,KAGA,SANA,MAEA,MASA,QAIA,KAEA,SALA,MAEA,IAIA,KACA,MAGA,KAGA,aAHwB,YAExB,WAGA,aACA,eAEA,UACA,IAEA,MACA,iBACA,UAGA,UACA,KACA,uBACA,KAEA,OACA,KAAoC,QAEpC,cACA,OACA,KACA,IACA,UACA,UAEA,OACA,OAkCA,KAEA,eAnCA,WACA,OACA,KACA,IACA,UACA,UAEA,IACA,QAiBA,KAEA,OAlBA,uBACA,KAEA,OACA,KAA4C,QAE5C,OACA,QAKA,KAGA,OAPA,OACA,MAEA,KAQA,KACA,MAGA,IAIA,KACA,MAGA,KAGA,aAHwB,YAExB,WAGA,aACA,mBAEA,UACA,IAEA,MACA,iBACA,UAGA,UACA,KACA,uBACA,KAEA,OACA,KAAoC,QAEpC,OACA,OAqEA,KAGA,aAvEA,uBACA,KAEA,OACA,KAAsC,QAEtC,cACA,OACA,KACA,IACA,UACA,UAEA,OACA,OA8CA,KAEA,eA/CA,WACA,OACA,KACA,IACA,UACA,UAEA,IACA,QA6BA,KAEA,OA9BA,uBACA,KAEA,OACA,KAA8C,QAE9C,OACA,QAiBA,KAGA,OAnBA,uBACA,KAEA,OACA,KAAgD,QAEhD,OACA,QAKA,KAGA,OAPA,OACA,MAEA,MAYA,KACA,MAGA,IAIA,KACA,MAGA,KAOA,aAHwB,YAExB,WAGA,aACA,SAEA,UACA,IAEA,MACA,iBACA,UAGA,UACA,OACA,KACA,IACA,YACA,UACA,UAGA,QAEA,MA2BA,MA1BA,SAWA,KAEA,SAZA,IACA,QAKA,KAGA,OAPA,OACA,QAEA,MAQA,SACA,OACA,IACA,SACA,OAEA,OAGA,WAAwB,YAExB,WAGA,aACA,aAEA,UACA,IAEA,MACA,iBACA,UAGA,WACA,OACA,KACA,IACA,UACA,UAEA,OACA,OAsBA,KAEA,eAvBA,WACA,OACA,KACA,IACA,UACA,UAEA,IACA,QAKA,KAEA,OANA,OACA,MAEA,IAIA,KACA,MAGA,eAIA,KACA,OACA,KACA,IACA,UACA,UAEA,OACA,OAsBA,KAEA,eAvBA,WACA,OACA,KACA,IACA,UACA,UAEA,IACA,QAKA,KAEA,OANA,OACA,MAEA,IAIA,KACA,MAGA,IAKA,CAGA,aAHwB,YAExB,WAGA,aACA,iBAEA,UACA,IAEA,MACA,iBACA,UAGA,WACA,OACA,KACA,IACA,UACA,UAEA,OACA,OA6CA,KAEA,eA9CA,WACA,OACA,KACA,IACA,UACA,UAEA,OACA,OA4BA,KAEA,aA7BA,uBACA,KAEA,OACA,KAA0C,QAE1C,cACA,OACA,KACA,IACA,UACA,UAEA,IACA,QAKA,KAEA,OANA,OACA,MAEA,IAIA,KACA,MAGA,IAIA,KACA,MAGA,eAIA,KACA,OACA,KACA,IACA,UACA,UAEA,OACA,OA6CA,KAEA,eA9CA,WACA,OACA,KACA,IACA,UACA,UAEA,OACA,OA4BA,KAEA,aA7BA,uBACA,KAEA,OACA,KAA4C,QAE5C,cACA,OACA,KACA,IACA,UACA,UAEA,IACA,QAKA,KAEA,OANA,OACA,MAEA,IAIA,KACA,MAGA,IAIA,KACA,MAGA,IAKA,CAGA,aAHwB,YAExB,WAGA,aACA,eAEA,UACA,IAEA,MACA,iBACA,UAGA,UACA,OACA,WACA,OACA,KACA,IACA,UACA,UAEA,OACA,OAkCA,KAEA,aAnCA,uBACA,KAEA,OACA,KAAwC,QAExC,cACA,OACA,KACA,IACA,UACA,UAEA,IACA,QAWA,KAEA,SAZA,IACA,QAKA,KAGA,OAPA,OACA,QAEA,KAQA,KACA,MAGA,IAIA,KACA,MAEA,QACA,UACA,OACA,WACA,OACA,KACA,IACA,UACA,UAEA,OACA,OAkCA,KAEA,aAnCA,uBACA,KAEA,OACA,KAA0C,QAE1C,cACA,OACA,KACA,IACA,UACA,UAEA,IACA,QAWA,KAEA,SAZA,IACA,QAKA,KAGA,OAPA,OACA,QAEA,KAQA,KACA,MAGA,IAIA,KACA,MAIA,KAGA,aAHwB,YAExB,WAGA,aACA,SAEA,UACA,KAEA,MACA,iBACA,UAGA,UACA,OACA,KACA,IACA,YACA,UACA,UAGA,QAEA,MASA,MARA,UACA,OAEA,OAEA,UAAwB,YAExB,WAGA,aACA,OAEA,UACA,KAGA,qBACA,UAGA,SACA,OACA,IACA,SACA,OAEA,OACA,IACA,SACA,OACA,IACA,SACA,OAEA,OAGA,WAAwB,YAGxB,YAEA,aACA,IAEA,WACA,KAGA,qBACA,UAGA,WACA,IACA,WACA,IACA,WACA,IACA,WACA,IACA,WACA,IACA,WACA,IACA,WAQA,gBAAwB,YAGxB,YAEA,aACA,IAEA,WACA,KAGA,qBACA,UAGA,WACA,IACA,WACA,IACA,WACA,IACA,WAKA,aAAwB,YAGxB,YAEA,aACA,aAEA,UACA,KAEA,MACA,iBACA,UAGA,UACA,iBACA,SACA,SAEA,IACA,KAAoC,QAEpC,OACA,OAqCA,KAGA,eAvCA,IACA,SAEA,aACA,OACA,KACA,IACA,UACA,UAEA,IACA,QAiBA,KAEA,mBAlBA,SACA,SAEA,IACA,KAA0C,QAE1C,OACA,QAKA,KAGA,OAPA,OACA,MAEA,KAQA,KACA,MAGA,KAOA,aAHwB,YAExB,WAGA,aACA,WAEA,UACA,KAEA,MACA,iBACA,UAGA,UACA,KACA,uBACA,KAEA,OACA,KAAoC,QAEpC,cACA,OACA,KACA,IACA,UACA,UAEA,IACA,QAiBA,KAEA,OAlBA,uBACA,KAEA,OACA,KAAwC,QAExC,OACA,QAKA,KAGA,OAPA,OACA,MAEA,KAQA,KACA,MAGA,KAGA,aAHwB,YAExB,WAGA,aACA,aAEA,UACA,KAEA,MACA,iBACA,UAGA,UACA,iBACA,SACA,SAEA,IACA,KAAoC,QAEpC,OACA,OAqCA,KAGA,eAvCA,IACA,SAEA,aACA,OACA,KACA,IACA,UACA,UAEA,IACA,QAiBA,KAEA,mBAlBA,SACA,SAEA,IACA,KAA0C,QAE1C,OACA,QAKA,KAGA,OAPA,OACA,MAEA,KAQA,KACA,MAGA,KAOA,aAHwB,YAExB,WAGA,aACA,WAEA,UACA,KAEA,MACA,iBACA,UAGA,UACA,KACA,uBACA,KAEA,OACA,KAAoC,QAEpC,cACA,OACA,KACA,IACA,UACA,UAEA,IACA,QAiBA,KAEA,OAlBA,uBACA,KAEA,OACA,KAAwC,QAExC,OACA,QAKA,KAGA,OAPA,OACA,MAEA,KAQA,KACA,MAGA,KAGA,aAHwB,YAExB,WAGA,aACA,SAEA,UACA,KAGA,qBACA,UAGA,WACA,KACA,SACA,KACA,KACA,KACA,uBACA,KAEA,OACA,KAAsC,QAEtC,OACA,KACA,OAEA,MACA,KAEA,MACA,QAiBA,KAIA,SApBA,eACA,WAEA,OACA,KAAwC,QAExC,OACA,QAKA,KAGA,OAPA,OACA,MAEA,aASwB,YAGxB,YAEA,aACA,SAEA,UACA,KAGA,qBACA,UAGA,SACA,KACA,KACA,KACA,uBACA,KAEA,OACA,KAAoC,QAEpC,OACA,KACA,OAEA,MACA,KAEA,MACA,QAiBA,KAGA,SAnBA,eACA,WAEA,OACA,KAAsC,QAEtC,OACA,QAKA,KAGA,OAPA,OACA,MAEA,YAQwB,YAGxB,YAEA,aACA,SAEA,UACA,KAGA,qBACA,UAGA,WACA,KACA,WACA,IACA,SACA,KACA,KACA,iBACA,SACA,SAEA,IACA,KAAwC,QAExC,OACA,KACA,OAEA,MACA,KAEA,MACA,QAiBA,KAKA,SArBA,eACA,WAEA,OACA,KAA0C,QAE1C,OACA,QAKA,KAGA,OAPA,OACA,MAEA,cAUwB,YAGxB,YAEA,aACA,aAEA,UACA,KAEA,MACA,iBACA,UAGA,UACA,KACA,uBACA,KAEA,OACA,KAAoC,QAEpC,OACA,OAsBA,KAGA,eAxBA,WACA,OACA,KACA,IACA,UACA,UAEA,IACA,QAKA,KAEA,OANA,OACA,KAEA,IAIA,KACA,MAGA,KAOA,aAHwB,YAExB,WAGA,aACA,SAEA,UACA,KAGA,qBACA,UAGA,SACA,KACA,KACA,iBACA,SACA,SAEA,IACA,KAAoC,QAEpC,OACA,KACA,OAEA,MACA,KAEA,MACA,QAiBA,KAGA,SAnBA,eACA,WAEA,OACA,KAAsC,QAEtC,OACA,QAKA,KAGA,OAPA,OACA,MAEA,YAQwB,YAGxB,YAEA,aACA,WAEA,UACA,KAGA,qBACA,UAGA,SACA,OACA,IACA,WAEA,KACA,QAgCA,KAEA,OAjCA,wBACA,KAEA,OACA,KAAsC,QAEtC,OACA,SACA,uBACA,KAEA,OACA,KAAwC,QAGxC,QACA,QAWA,KAGA,SAbA,IACA,QAKA,KAGA,OAPA,OACA,QAEA,OAYA,SACA,OACA,IACA,SACA,OAEA,OAGA,WAAwB,YAGxB,YAEA,aACA,eAEA,UACA,KAGA,qBACA,UAGA,SACA,KACA,uBACA,KAEA,OACA,KAAoC,QAEpC,OACA,SAEA,MACA,QAqCA,KAEA,OAtCA,OACA,KACA,QAsBA,KAEA,OAvBA,uBACA,KAEA,OACA,KAAwC,QAExC,OACA,QAUA,KAGA,SAZA,KACA,QAIA,KAGA,SANA,QAEA,OAYA,QAKA,KAGA,OAPA,OACA,MAEA,MAQA,SACA,KACA,uBACA,KAEA,OACA,KAAsC,QAEtC,OACA,QAqCA,KAIA,OAxCA,OACA,KACA,QAsBA,KAEA,OAvBA,uBACA,KAEA,OACA,KAA0C,QAE1C,OACA,QAUA,KAGA,SAZA,KACA,QAIA,KAGA,SANA,QAEA,OAYA,QAKA,KAGA,OAPA,OACA,MAEA,aASwB,YAGxB,YAEA,aACA,OAEA,UACA,KAGA,qBACA,UAGA,SACA,OACA,IACA,SACA,OAEA,OAEA,UAAwB,YAGxB,YAEA,aACA,aAEA,UACA,KAEA,MACA,iBACA,UAGA,UACA,KACA,uBACA,KAEA,OACA,KAAoC,QAEpC,OACA,SAEA,aACA,MACA,KACA,IACA,YACA,UACA,UAGA,QAEA,MACA,QA0BA,KAEA,OA3BA,KACA,KACA,uBACA,KAEA,OACA,KAAwC,QAExC,OACA,KACA,OAEA,MACA,KAEA,MACA,QAKA,KAGA,OAPA,OACA,MAEA,KAQA,KACA,MAEA,QACA,UACA,KACA,uBACA,KAEA,OACA,KAAsC,QAEtC,cACA,MACA,KACA,IACA,YACA,UACA,UAGA,QAEA,MACA,QA0BA,KAEA,OA3BA,KACA,KACA,uBACA,KAEA,OACA,KAA0C,QAE1C,OACA,KACA,OAEA,MACA,KAEA,MACA,QAKA,KAGA,OAPA,OACA,MAEA,KAQA,KACA,MAIA,KAGA,aAHwB,YAExB,WAGA,aACA,OAEA,UACA,KAGA,qBACA,UAGA,SACA,iBACA,SACA,SAEA,IACA,KAAoC,QAEpC,OACA,SACA,OAEA,MACA,IACA,SACA,iBACA,SACA,SAEA,IACA,KAAsC,QAEtC,OACA,SACA,OAEA,MAGA,WAAwB,YAGxB,YAEA,aACA,aAEA,UACA,KAEA,MACA,iBACA,UAGA,UACA,KACA,uBACA,KAEA,OACA,KAAoC,QAEpC,cACA,OACA,KACA,IACA,UACA,UAEA,IACA,QAiBA,KAEA,OAlBA,uBACA,KAEA,OACA,KAAwC,QAExC,OACA,QAKA,KAGA,OAPA,OACA,KAEA,KAQA,KACA,MAEA,QACA,SACA,KACA,uBACA,KAEA,OACA,KAAsC,QAEtC,OACA,QA0BA,KAEA,SA3BA,IACA,SAEA,MACA,QAiBA,KAGA,OAnBA,uBACA,KAEA,OACA,KAA0C,QAE1C,OACA,QAKA,KAGA,OAPA,OACA,MAEA,eAYA,IACA,KACA,uBACA,KAEA,OACA,KAAwC,QAExC,cACA,MACA,KACA,IACA,YACA,UACA,UAGA,QAEA,MACA,QAiBA,KAEA,OAlBA,uBACA,KAEA,OACA,KAA4C,QAE5C,OACA,QAKA,KAGA,OAPA,OACA,MAEA,KAQA,KACA,MAEA,QACA,UACA,KACA,uBACA,KAEA,OACA,KAA0C,QAE1C,cACA,MACA,KACA,IACA,YACA,UACA,UAGA,QAEA,MACA,QAuBA,KAEA,SAxBA,IACA,QAiBA,KAGA,OAnBA,uBACA,KAEA,OACA,KAAgD,QAEhD,OACA,QAKA,KAGA,OAPA,OACA,QAEA,MAYA,KACA,MAGA,IAGA,CAGA,aAHwB,YAExB,WAGA,aACA,aAEA,UACA,KAEA,MACA,iBACA,UAGA,WACA,OACA,KACA,IACA,UACA,UAEA,OACA,OAsBA,KAGA,eAxBA,WACA,OACA,KACA,IACA,UACA,UAEA,IACA,QAKA,KAEA,OANA,OACA,MAEA,IAIA,KACA,MAGA,KAOA,aAHwB,YAExB,WAGA,aACA,iBAEA,UACA,KAEA,MACA,iBACA,UAGA,WACA,OACA,KACA,IACA,UACA,UAEA,OACA,OA6CA,KAGA,eA/CA,WACA,OACA,KACA,IACA,UACA,UAEA,OACA,OA4BA,KAEA,aA7BA,uBACA,KAEA,OACA,KAA0C,QAE1C,cACA,OACA,KACA,IACA,UACA,UAEA,IACA,QAKA,KAEA,OANA,OACA,MAEA,IAIA,KACA,MAGA,IAIA,KACA,MAGA,KAOA,aAHwB,YAExB,WAGA,aACA,IAEA,WACA,KAGA,qBACA,UAGA,WACA,IACA,WACA,IACA,WAIA,YAAwB,YAGxB,YAEA,aACA,eAEA,UACA,KAEA,MACA,iBACA,UAGA,UACA,KACA,wBACA,KAEA,OACA,KAAoC,QAEpC,cACA,OACA,KACA,IACA,UACA,UAEA,cACA,OACA,KACA,IACA,UACA,UAEA,cACA,OACA,KACA,IACA,UACA,UAEA,IACA,QAiBA,KAEA,OAlBA,wBACA,KAEA,OACA,KAA4C,QAE5C,OACA,QAKA,KAGA,OAPA,OACA,MAEA,KAQA,KACA,MAEA,IACA,KACA,MAEA,IACA,KACA,MAGA,KAGA,aAHwB,YAExB,WAGA,aACA,yBAEA,UACA,KAEA,MACA,iBACA,UAGA,WACA,OACA,KACA,IACA,UACA,UAEA,OACA,OAqFA,KAEA,eAtFA,WACA,OACA,KACA,IACA,UACA,UAEA,OACA,OAoEA,KAEA,aArEA,uBACA,KAEA,OACA,KAA0C,QAE1C,cACA,OACA,KACA,IACA,UACA,UAEA,OACA,OA6CA,KAEA,eA9CA,WACA,OACA,KACA,IACA,UACA,UAEA,OACA,OA4BA,KAEA,aA7BA,uBACA,KAEA,OACA,KAAkD,QAElD,cACA,OACA,KACA,IACA,UACA,UAEA,IACA,QAKA,KAEA,OANA,OACA,QAEA,IAIA,KACA,MAGA,IAIA,KACA,MAGA,IAIA,KACA,MAGA,IAIA,KACA,MAGA,eAIA,KACA,OACA,KACA,IACA,UACA,UAEA,OACA,OAmDA,KAEA,eApDA,WACA,OACA,KACA,IACA,UACA,UAEA,OACA,OAkCA,KAEA,aAnCA,uBACA,KAEA,OACA,KAA4C,QAE5C,cACA,OACA,KACA,IACA,UACA,UAEA,IACA,QAWA,KAEA,SAZA,IACA,QAKA,KAGA,OAPA,OACA,QAEA,KAQA,KACA,MAGA,IAIA,KACA,MAGA,IAKA,CAGA,aAHwB,YAExB,WAGA,aACA,SAEA,UACA,KAGA,qBACA,UAGA,SACA,KACA,uBACA,KAEA,OACA,KAAoC,QAEpC,OACA,QAWA,KAGA,SAbA,KACA,QAKA,KAGA,OAPA,OACA,MAEA,YAQwB,YAGxB,YAEA,aACA,2BAEA,UACA,KAGA,qBACA,UAGA,SACA,KACA,OACA,IACA,QAsEA,KAEA,SAvEA,IACA,QAgEA,KAGA,SAlEA,IACA,QA0DA,KAGA,SA5DA,IACA,QAoDA,KAGA,OAtDA,uBACA,KAEA,OACA,KAA4C,QAE5C,OACA,QAwCA,KAGA,SA1CA,IACA,QAkCA,KAGA,SApCA,IACA,QA4BA,KAGA,OA9BA,uBACA,KAEA,OACA,KAAkD,QAElD,OACA,QAgBA,KAGA,SAlBA,IACA,QAUA,KAGA,SAZA,IACA,QAIA,KAGA,SANA,sBAEA,cAwCA,SACA,OAEA,OAEA,UAAwB,YAGxB,YAEA,aACA,yBAEA,UACA,KAGA,qBACA,UAGA,SACA,KACA,OACA,IACA,QAmEA,KAEA,SApEA,IACA,QA6DA,KAGA,OA/DA,uBACA,KAEA,OACA,KAAwC,QAExC,OACA,QAiDA,KAGA,SAnDA,IACA,QA2CA,KAGA,SA7CA,IACA,QAqCA,KAGA,OAvCA,uBACA,KAEA,OACA,KAA8C,QAE9C,OACA,QAyBA,KAGA,SA3BA,IACA,QAmBA,KAGA,SArBA,IACA,QAaA,KAGA,SAfA,IACA,SAEA,MACA,QAIA,KAGA,SANA,oBAEA,aAoCA,SACA,OAEA,OAEA,UAAwB,YAGxB,YAEA,aACA,qCAEA,UACA,KAGA,qBACA,UAGA,SACA,KACA,OACA,IACA,QA4HA,KAEA,SA7HA,IACA,QAsHA,KAGA,OAxHA,uBACA,KAEA,OACA,KAAwC,QAExC,OACA,QA0GA,KAGA,SA5GA,IACA,QAoGA,KAGA,SAtGA,IACA,QA8FA,KAGA,OAhGA,uBACA,KAEA,OACA,KAA8C,QAE9C,OACA,QAkFA,KAGA,SApFA,IACA,QA4EA,KAGA,SA9EA,IACA,QAsEA,KAGA,SAxEA,IACA,SAEA,MACA,QA6DA,KAGA,OA/DA,uBACA,KAEA,OACA,KAAsD,QAEtD,OACA,SACA,uBACA,KAEA,OACA,KAAwD,QAGxD,QACA,QAwCA,KAGA,SA1CA,IACA,QAkCA,KAGA,SApCA,IACA,QA4BA,KAGA,OA9BA,uBACA,KAEA,OACA,KAA4D,QAE5D,OACA,QAgBA,KAGA,SAlBA,IACA,QAUA,KAGA,SAZA,IACA,QAIA,KAGA,SANA,gCAEA,mBA4DA,SACA,OAEA,OAEA,UAAwB,YAGxB,YAEA,aACA,aAEA,UACA,KAGA,qBACA,UAGA,SACA,OACA,IACA,QAmCA,KAEA,OApCA,uBACA,KAEA,OACA,KAAsC,QAEtC,OACA,QAuBA,KAGA,SAzBA,IACA,QAiBA,KAGA,OAnBA,uBACA,KAEA,OACA,KAA0C,QAE1C,OACA,QAKA,KAGA,OAPA,OACA,QAEA,QAgBA,SACA,OACA,IACA,QAuBA,KAIA,OA1BA,uBACA,KAEA,OACA,KAAwC,QAExC,OACA,QAWA,KAGA,SAbA,IACA,QAKA,KAGA,OAPA,OACA,QAEA,cAawB,YAGxB,YAEA,aACA,IAEA,WACA,KAGA,qBACA,UAGA,mBACA,iBACA,WAEA,OACA,KAAoC,QAGpC,aAAwB,YAGxB,YAEA,aACA,SAEA,UACA,KAGA,qBACA,UAGA,SACA,uBACA,KAEA,OACA,KAAoC,QAEpC,OACA,SACA,KACA,uBACA,KAEA,OACA,KAAsC,QAEtC,OACA,QAgBA,KAIA,OAnBA,uBACA,KAEA,OACA,KAAwC,QAExC,OACA,QAIA,KAGA,SANA,MAEA,aASwB,YAGxB,YAEA,aACA,IAEA,WACA,KAGA,qBACA,UAGA,WACA,IACA,WAGA,WAAwB,YAGxB,YAEA,aACA,OAEA,UACA,KAGA,qBACA,UAGA,SACA,KACA,OACA,eACA,WAEA,OACA,KAAoC,QAEpC,OACA,KACA,OAEA,MACA,KAGA,YAAwB,YAGxB,YAEA,aACA,IAEA,WACA,KAGA,qBACA,UAGA,mBACA,iBACA,WAEA,OACA,KAAoC,QAGpC,aAAwB,YAGxB,YAEA,aACA,OAEA,UACA,KAGA,qBACA,UAGA,mBACA,iBACA,WAEA,OACA,KAAoC,QAEpC,OACA,SACA,KACA,uBACA,KAEA,OACA,KAAsC,QAEtC,OACA,SACA,OAEA,MAGA,WAAwB,YAGxB,YAEA,aACA,IAEA,WACA,KAGA,qBACA,UAGA,mBACA,iBACA,WAEA,OACA,KAAoC,QAGpC,aAAwB,YAGxB,YAEA,cACA,SAEA,UACA,KAEA,MACA,iBACA,UAGA,UACA,OACA,KACA,IACA,YACA,UACA,UAGA,QAEA,MASA,MARA,UACA,OAEA,OAEA,UAAwB,YAExB,WAGA,cACA,OAEA,UACA,KAGA,qBACA,UAGA,SACA,iBACA,SACA,SAEA,IACA,KAAoC,QAEpC,OACA,SACA,OAEA,MACA,IACA,SACA,iBACA,SACA,SAEA,IACA,KAAsC,QAEtC,OACA,SACA,OAEA,MACA,IACA,SACA,iBACA,SACA,SAEA,IACA,KAAwC,QAExC,OACA,SACA,OAEA,MACA,IACA,SACA,iBACA,SACA,SAEA,IACA,KAA0C,QAE1C,OACA,SACA,OAEA,MACA,IACA,SACA,iBACA,SACA,SAEA,IACA,KAA4C,QAE5C,OACA,SACA,OAEA,MACA,IACA,SACA,iBACA,SACA,SAEA,IACA,KAA8C,QAE9C,OACA,SACA,OAEA,MACA,IACA,SACA,iBACA,SACA,SAEA,IACA,KAAgD,QAEhD,OACA,SACA,OAEA,MACA,IACA,WASA,kBAAwB,YAGxB,YAEA,cACA,yBAEA,UACA,KAGA,qBACA,UAGA,SACA,iBACA,SACA,SAEA,IACA,KAAoC,QAEpC,OACA,QA6DA,KAEA,OA9DA,OACA,IACA,QA8CA,KAEA,SA/CA,IACA,QAwCA,KAGA,SA1CA,IACA,QAkCA,KAGA,SApCA,IACA,QA4BA,KAGA,SA9BA,IACA,QAsBA,KAGA,SAxBA,IACA,QAgBA,KAGA,SAlBA,IACA,QAUA,KAGA,SAZA,IACA,QAIA,KAGA,SANA,kBAEA,YAgCA,QAKA,KAGA,OAPA,OACA,MAEA,MAQA,SACA,iBACA,SACA,SAEA,IACA,KAAsC,QAEtC,OACA,QAqCA,KAIA,OAxCA,OACA,IACA,QAsBA,KAEA,SAvBA,IACA,QAgBA,KAGA,SAlBA,IACA,QAUA,KAGA,SAZA,IACA,QAIA,KAGA,SANA,UAEA,QAgBA,QAKA,KAGA,OAPA,OACA,MAEA,aASwB,YAGxB,YAGA,mBAGA,UACA,UAGA,QAFA,SACA,UAGA,eACA,IACA,OAEA,uBACA,OAAmB,gCACnB,KAEA,aADA,QAGA,mBACA,gBAGA,eACA,aACA,SACA,KACA,oBAEA,gBAEA,uCAEA,KAEA,cACA,IAGA,GACA,IAFA,MAGA,cACA,UACA,SAEA,eACA,GACA,UACA,aACA,WAGA,YACA,gBACA,eACA,QAEA,sBACA,OArBA,sCAsBA,iBAGA,GACA,QAGA,IAvsHA,IAiIA,sCA5IA,MAEA,MAAkC,CAClC,SAGA,kBAA6B,UAC7B,EACA,SACA,OAAkB,sCAClB,UACkB,wBAClB,oBACA,OAAkB,sCAClB,UACA,OAAmB,sCACnB,qBAAkC,2BAClC,gBAAkC,0BAClC,kBAAyC,mBACzC,gBAAkC,UAClC,gBAAkC,SAClC,KACA,OAAmB,sCACnB,UACA,OAAmB,sCACnB,uBAAwC,yBACxC,gBAAmC,kBACnC,gBAAkC,eAClC,KACA,SAAmB,wCACnB,kBACA,mBAAmC,mCACnC,KACA,OAAmB,sCACnB,YACA,YAAmB,2CACnB,eACA,QAAmB,uCACnB,sBAAkC,SAClC,gBAAkC,SAClC,KACA,QAAmB,uCACnB,uBAA8B,SAC9B,KACA,OAAmB,sCACnB,UACA,OAAmB,sCACnB,uBAAyC,2CACzC,gBAAkC,qCAClC,KACA,OAAmB,sCACnB,qBAAoC,kBACpC,KACA,OAAmB,sCACnB,qBAAoC,qBACpC,gBAAkC,wCAClC,KACA,UAAmB,yCACnB,uBAA8B,4BAC9B,KACA,WAAmB,0CACnB,wBAA8B,4BAC9B,eAA8B,0BAC9B,gBAAmC,gCACnC,gBAAoC,yBACpC,kBAA2C,mCAC3C,gBAAmC,SACnC,KACA,OAAmB,sCACnB,UACA,OAAmB,sBAA2B,gBAC9C,UACA,OAAmB,sBAA2B,gBAC9C,qBAAoC,+BACpC,kBAAwC,sCACxC,gBAAoC,YACpC,gBAAkC,kBAClC,KACA,OAAmB,sCACnB,qBAAkC,kBAClC,KACA,OAAmB,sCACnB,UACA,OAAmB,sCACnB,uBAAwC,4CACxC,kBAAwC,wCACxC,KACA,YAAmB,yCACnB,aACA,QAAmB,uCACnB,YACA,QAAmB,uCACnB,YACA,gBAAmB,4CACnB,gBACA,YAAmB,wCACnB,YACA,OAAmB,sCACnB,oBAA8B,SAC9B,KACA,qBAAmB,kDACnB,iCAA+B,kBAC/B,KACA,SAAmB,wCACnB,0BAA8B,UAC9B,KACA,UAAoB,yCACpB,2BAA+B,WAC/B,KACA,SAAoB,wCACpB,wBAA+B,WAC/B,KACA,SAAoB,wCACpB,wBAA+B,WAC/B,KACA,SAAoB,wCACpB,wBAA+B,WAC/B,KACA,SAAoB,wCACpB,wBAA+B,WAC/B,KACA,SAAoB,wCACpB,wBAA+B,WAC/B,KACA,SAAoB,wCACpB,yBAAqC,sBACrC,KACA,SAAoB,wCAEpB,cACA,KACA,KACA,KAAgC,iBAChC,cACA,KACA,MAEA,KACA,uBAGA,SACA,iFAGA,eACA,UAUA,QAs/GA,SAkEA,qBACA,OAEA,8BACA,UAAkB,wBAGlB,gCA9/GA,OA2DA,8BAEA,WACA,sBA7DA,OAEA,0BACA,wBACA,aACW,kBACX,YAEA,EAEA,CAEA,OACA,iBACA,gBAEA,GAGA,GAEA,CA2CA,IACA,4BA3CA,SAoBA,YAFA,cAEmB,MAAqB,OACxC,cAGA,qBACA,8BACA,MACA,kBACA,KAEA,sBA7BA,cAA4B,qCAAoD,aAEhF,OACA,iBACA,qBACA,uBACA,qBACA,qBACA,qBACA,qBACA,qDAA+D,cAAyB,IACxF,8CAA+D,aAAyB,IACxF,yCAA+D,cAAyB,IACxF,yCAA+D,aAAyB,IACxF,EAEA,SAeA,uCACA,SAEA,CAYA,gBACA,OAEA,OAEA,EAq7GA,WAEA,qBApvHA,aAAqB,MAA0B,aAC/C,eACA,sBACA,KAEA,IAaA,OAmuHA,CACA,cAEA,QAAC,iBChwHD,aAkMA,UACA,CACA,QAnMA,WACA,kBA8BA,UACA,UAGA,QAFA,SACA,UAGA,cACA,IAOA,OANA,QACA,UACA,SAEA,aAMA,QACA,gEAGA,gBAEA,KACA,SACA,UAEA,QAGA,cACA,QACA,gBAEA,cACA,OACA,qBACK,OACL,2BAEA,SAEA,KAEA,cACA,aACA,KAAmB,MAAmB,OACtC,MACA,KACA,gDACO,OACP,2CAIA,QACA,QAEA,cACA,SACA,sBACA,SACA,SAEA,OACA,4CAEA,aACA,gBACA,QACA,GAEA,cACA,SACA,sBACA,SACA,SAEA,UACA,QAEA,8BACA,OACA,iBACA,KACA,gBACA,QAEA,uBACA,OACA,KACA,QACA,GACA,4CAEA,UAMA,sBACA,IACA,KACA,KACA,YACA,KACA,QAEA,cACA,UACA,OACA,iBACA,KACA,+BACA,KAEA,YAEO,aAEP,sDAGA,aACA,8CACA,iBAIA,IACA,QAEA,cAEA,OACA,oBACA,OACA,KACA,aACO,6DAEA,gBACP,+CACA,oCAEA,OAGA,UACA,MAEA,cACA,QACA,uBAIA,KACA,OA7LA,KACA,KACA,KACA,GAGA,sBAGA,IACA,UACA,iBACA,OACA,UACA,SACA,KACA,UACA,aACA,KACA,UACA,YAKA,MACA,QAEA,CApBA,mGCJA,IACA,mBAKA,cACA,CAEA,kBACA,eACA,uBACA,aACA,gBACA,UACA,8BACA,oBACA,eACA,UACA,aACA,6BAEA,2EACA,sEACA,eAKA,sBACA,OACA,qBACA,eACA,eACA,mBACA,8BACA,2BACA,mBACA,wBACA,sCACA,qBAGA,gEACA,IAIA,gBAHA,gBAEA,cAMA,oCACA,IACA,sBACA,cACA,oBACA,kBACA,eACA,QAKA,SAEA,iDACA,sBACA,4EAEA,wEACA,aACA,mBACA,YAEA,cACA,QAMA,gBACA,kCACA,WACA,wBAEA,oBAKA,UACA,aACA,UAMA,iBAHA,4EACA,kFACA,iBAMA,mBACA,OACA,WACA,eACA,qBACA,qBACA,gBACA,qBACA,2BAEA,aAKA,kBAEA,OAEA,KAQA,MAPA,8BACA,wBACA,yBAIA,MAMA,2BACA,OACA,0BAKA,qBACA,MACA,QAKA,uBACA,MACA,UAKA,oBACA,MACA,sBACA,UAKA,qBACA,MACA,wBACA,WAKA,qBACA,MACA,YACA,MAKA,sBACA,OACA,gDACA,KAKA,uBACA,OACA,kDACA,KAKA,oBACA,OACA,mBAEA,SAEA,2BACA,oBACA,mBACA,mBACA,kBACA,kBAEA,UACA,WACA,eACA,sBACA,GACA,sBAEA,UAKA,iBACA,MACA,wBACA,sBACA,2DAEA,iBAKA,kBACA,OACA,uDACA,QACA,uEChPA,IACA,mBAKA,uBACA,qBACA,IAKA,cACA,CACA,aACA,gBACA,gBACA,8BACA,+BACA,SAKA,WACA,6CACA,uBACA,yCACA,sBACA,KACA,EAKA,SAEA,kBAEA,cACA,QAGA,kCACA,GAWA,6BATA,qCACA,oBAGA,sDAEA,kCAEA,YAMA,OACA,gCACA,KAKA,UACA,MACA,yBAEA,uBAEA,UAKA,YAJA,wCAGA,OAMA,QACA,CACA,QAKA,mBACA,SAEA,eAEA,uCAGA,4BACA,4DACA,aAEA,gBAAO,KAGP,4BACA,8DACA,aAEA,gBAEA,CAKA,qBACA,aACA,2BACA,sBACA,mCACA,KAKA,sBACA,aACA,4BACA,wBACA,qCACA,KAKA,YACA,wBACA,UAKA,cACA,2BACA,UAKA,SACA,MACA,mCACA,6BACA,aAKA,WACA,aACA,iBACA,8BACA,+BACA,aAKA,eAEA,MACA,cAEA,gBAGA,QAKA,2BAEA,cACA,uCACA,yBAAkD,WAClD,MAIA,MAKA,aACA,+BACA,aAKA,qBACA,UACA,uBAKA,4BACA,4BACA,oBACA,YACA,wDACA,yDAGA,GACA,IAKA,iBACA,MACA,QAKA,kBACA,MACA,QAEA,uBACA,MACA,oBAEA,sBACA,MACA,oBAEA,SACA,MACA,+CACA,OAEA,UACA,MACA,+CACA,OAKA,UAEA,CACA,QACA,oCC1OA,iBAGA,eAGA,gBACA,IACA,MAWA,oBAVA,0BACA,uBACA,0BACA,yBACA,SACA,GACA,MAEA,KACA,KAGA,SACA,CACA,OACA,MAtDA,IAOA,SAA6B,SAAiB,YAG9C,gBAGA,YAEA,0BAIA,kBAA0B,gBAAS,WACnC,KAAgB,IAChB,UAAgB,IAChB,aACA,cAEA,MAIA,EA5BA,UAKA,mECNgB,GAEhB,GAIA,GACA,mBAKA,cACA,CAEA,iBAEA,sBACA,gBACA,0BACA,yBACA,yBACA,eACA,gBACA,UACA,+BAGA,6BACA,UACA,UACA,UAEA,uCACA,qDACA,wCACA,iBAKA,sBACA,OACA,MASA,sBARA,oBACA,iGACA,6FACA,eACA,eACA,mBACA,gCACA,IAMA,oCACA,eAEA,aACA,cACA,eACA,QAKA,gBACA,4BACA,WACA,wBAEA,oBAKA,sBACA,MACA,uBACA,yDACA,0DACA,2DACA,qDAEA,iBAKA,qBACA,aACA,eAKA,sBACA,MACA,uBACA,yDACA,0DACA,2DACA,qDAEA,iBAKA,qBACA,aACA,eAKA,SACA,MACA,4BACA,QAKA,mBACA,OACA,WACA,eACA,oBACA,oCACA,+BACA,eACA,gBACA,oBAEA,SAKA,UACA,aACA,UAoBA,YAnBA,qEACA,sEACA,uEACA,iEACA,6BAEA,sBACA,qEACA,sEACA,uEACA,iEACA,6BAGA,kEACA,iEACA,oDAEA,mBAMA,2BACA,OACA,0BAMA,kBACA,aACA,yEACA,KAKA,0BACA,MACA,sCAEA,iBACA,sCAEA,WAKA,4BACA,MACA,sCAEA,mBACA,oCAEA,aAKA,qBACA,MACA,QAKA,uBACA,MACA,UAKA,oBACA,MACA,sBACA,gBACA,yBAKA,qBACA,MACA,wBACA,iBACA,2BAKA,mBACA,MACA,iBACA,yBAKA,oBACA,MACA,mBACA,2BAKA,kBACA,MACA,SAKA,gBACA,MACA,QAKA,oBACA,iCACA,2BAEA,gBAOA,qBACA,MACA,YACA,MAKA,sBACA,OACA,2BACA,yBAKA,uBACA,OACA,4BACA,2BAKA,oBACA,OACA,mBAMA,SACA,OACA,WACA,cACA,gEACA,2BAEA,GAKA,iBAEA,MAEA,wBAEA,sBACA,qDAEA,iBAKA,kBACA,OACA,iDACA,QAKA,sBACA,yBACA,4BACA,sCACA,YACA,CACA,yBACA,4BACA,sCACA,YACA,CACA,CAKA,WAEA,aACA,SAGA,sFACA,6EAEA,OACA,QAEA,sBCxWA,CAEA,YACA,4BACA,2BACA,sBAuQA,aACA,OACA,qBAEA,aACA,OACA,mBAEA,aACA,2BACA,SAEA,aACA,YACA,OApRA,EAEA,UACA,iBAEA,2BACA,YAGA,qBACA,sBAGA,GACA,uCACA,gBACA,yBACA,2CACA,gBACA,MAEA,4BACA,eAEA,UACA,uBAGA,IACA,4BACA,kDACA,uBACA,eACA,OACO,YAEP,4DACA,KAEA,QADA,WAKA,WAEA,WACA,KAEA,YACA,sBAEA,YACA,UACA,MACA,UACA,yBACA,IACA,UACA,sCACA,IAEA,MACA,+CACA,WAEG,iBACH,gDACA,OACA,YACA,SAAe,EAAS,IACxB,eAGA,QACA,UAEA,qCACA,IAEA,OACA,qBAEA,2CACA,uBAIA,iBACA,uBACA,oBACA,YAEA,iBAEA,kBAGA,4BAGA,8BAGA,mBARA,kDASA,kBACA,iBAKA,yBAHA,sCAIA,2BACA,kBAGA,yJACA,QAEA,0CAKA,UACA,MAEA,uCAEA,8BACA,aAMA,MAGA,wBACA,kBAEA,WAEA,KAbA,qBAEA,kCAEA,eAUA,gBAEA,QACA,IAEA,EACA,wCACA,WAEA,MACA,qBAEA,uDACA,iBAEA,gBACA,eACA,UAEA,EACA,wBACA,yBACA,wBACA,0BAEG,mCACH,KAAoB,IACpB,UACA,2CACA,CACA,IACA,KAGA,IACA,UAEA,MACA,uBACA,cAEA,uBAGA,gBACA,0BACA,qBAEA,OACA,OAEA,0CACA,OAEA,WACA,cAGA,uBACA,qBACA,mCACA,QACA,wBACA,WAIA,6BACA,eACA,QACA,2BAEA,qDACA,+BACA,GACA,IAEA,WAEA,WACA,UACG,wBAEH,aACA,yCAEA,uBAEA,WACA,MAEA,iCACA,IACA,GAOA,4BANA,kBAEA,kBAEA,4BACA,QAJA,MAOA,qCACA,iBACA,YAEA,cACA,WACA,GACA,cACA,MACA,OACA,IAEA,6BACA,UACA,kDC7PA,WAGA,CACA,mCAGA,UACA,mDACA,SAKA,mCAJA,aACA,KAEA,IAKA,MACA,UACA,oBACA,qBAIA,EA1BA,IA2BA,UACA,uBACA,qDChDA,eACA,CAEA,kCAFkC,OAClC,KAUA,KACA,eAGA,+CAGA,aACA,YACA,UACA,SACA,SACA,UACA,SACA,SACA,UACA,YACA,SACA,UACA,aAMA,eAEA,OAEA,OACA,qBAIA,iBAEA,SACA,CACA,0CAnDA,mBCXA,aAEA,IACA,eAGA,eACA,iDAEA,8CAAwC,sBAGxC,cAEA,wEAAwC,yBAKxC,cAAiB,IAAK,KAAI,IAAK,KAAI,IAAS,MAC5C,kECpBA,2CAKA,QACA,8CCNA,iBAoBA,aACA,6BACA,qBACA,KACA,IAxBA,QAGA,WACA,CACA,WAEA,MACA,OACA,4CAUA,+CnBNA,mBAEA,SAGA,MACA,YACA,CACA,YAKA,MACA,YACA,SACA,IAIA,WACA,SACA,UAGA,YACA,QAEA,uCAMA,KACA,IACA,kBAKA,MACA,OACA,WAKA,MACA,IACA,OACA,WAIA,MACA,OACA,WAIA,MA1EA,MAYA,IAgEA,6BAGA,OACA,kCACA,SAEA,sBACA,yBACA,qBACA,0BACA,8BACA,mCAGA,YAGA,SAIA,MACA,UAIA,KAEA,OACA,eACA,eAEA,WACA,eAAmB,MAAkB,WACrC,OAIA,SACA,UACA,UACA,UAGA,aAEA,EA5BA,KA+BA,SADA,EA5BA,IA+BA,KACA,CACA,KACA,KACA,CAEA,CACA,WAAc,KAGd,KACA,KACA,IACA,kBoB7IA,aAEA,IACA,aACA,4BACA,iBACA,kCACA,8CCLA,IACA,SAAyB,0DAAsE,MAC/F,4BACA,4DACA,kBACA,0DACA,GASA,+DCd6B,GAE7B,GAIA,GACA,mBAKA,cAEA,CAEA,iBAEA,sBACA,eACA,cACA,SACA,aACA,cACA,YACA,gBACA,UACA,+BAEA,0DACA,qDACA,eAKA,sBACA,OACA,MAUA,sBATA,YACA,QACA,YACA,iBACA,gBACA,eACA,mBACA,gCACA,IAMA,oCACA,IACA,+BACA,2BACA,6BACA,uBACA,uBACA,YACA,cACA,eACA,QAKA,gBACA,8CACA,WACA,wBAEA,oBAKA,UACA,aACA,UAIA,iBAHA,4EACA,kFACA,iBAMA,mBACA,OACA,WACA,eACA,YACA,SACA,aACA,kBACA,iBACA,gBACA,qBAEA,SAKA,2BACA,OACA,0BAKA,kBACA,OACA,UACA,WAEA,GAKA,qBACA,MACA,QAKA,uBACA,MACA,UAKA,oBACA,MACA,sBACA,UAKA,qBACA,MACA,wBACA,WAKA,qBACA,aACA,kCACA,YACA,MAKA,sBACA,OAEA,gCACA,eACA,wDAEA,KAKA,uBACA,OAEA,iCACA,eACA,yDAEA,KAKA,oBACA,OACA,mBAKA,wBACA,aAEA,6CACA,sBAEA,6CACA,oEAEA,iDAEA,iBACA,KAKA,6BAEA,MAEA,kBACA,gCACA,gCAEA,+BACA,8BAEA,mBACA,kBACA,wBAGA,iCACA,0BAEA,OAEA,8BACA,KAKA,0BAEA,MACA,iBAEA,4BACA,oBACA,iBACA,iBACA,eACA,eAEA,UACA,YACA,sCAGA,qDACA,uEAEA,yBACA,6BAEA,KAEA,mBACA,oBACA,2CACA,2CACA,sBAEA,oBACA,oBACA,2CACA,sBAKA,iBACA,OACA,sBACA,wEACA,uBAEA,mBAKA,kBACA,OACA,mEACA,cACA,mBAEA,4CC7PA,YAKA,wDACA,WAAuB,GACvB,UAAwB,IACxB,UAAqB,GACrB,oBACA,CACA,qBACA,wBACA,eAEA,aAIA,CACA,YAEA,8BACA,QAIA,CACA,YAGA,0CACA,GAIA,eACA,cAGA,gBACA,kBAEA,UACA,kBAGA,uDAGA,EACA,QAGA,sBAEA,sBAIA,YAAiC,aAAsB,aAAW,WAClE,UACA,eACA,WAAoB,IACpB,WAAoB,IACpB,YAAoB,IACpB,gBACA,mBAGA,QAAkC,aAAa,iCAC/C,UACA,eACA,WAAoB,IACpB,WAAoB,IACpB,YAAoB,IACpB,gBACA,mBAGA,qBACA,UACG,uBAEH,UACA,GAIA,CACA,YACA,oCACA,oBAGA,8BACA,GACA,WACA,gBACA,OACA,wGA/IA,QAEA,IACA,EAGA,IAEA,yBAKA,eAGA,IACA,8BAEA,KACA,OAEA,iBACA,kDACA,sCAGA,iDAIA,KACA,IACA,IAEA,GACA,0CACA,aACA,eACA,IACA,IACA,GAAC,mBCvCD,CACA,QACA,mCAEA,aACA,2BAaA,4BCpBA,cAIA,KACA,YAAmgG,qsGAEngG,2DCPA,QAIA,QAQA,IAKA,mBAKA,mBAKA,uBACA,2DCxBA,QACA,YACA,kBACA,mBACA,mBACA,mCCLA,YACA,yDACA,KAIA,CACA,aAGA,2BAGA,gBACA,qBACA,mBACA,yBACA,2BAKA,gBAEA,cACA,MACA,cAAiB,MAAkB,OAGnC,iBACA,2BACA,0BACA,6BACA,gCACA,cACA,WACA,sBACA,yBAIA,UACA,QAIA,SACA,QAIA,CACA,aACA,OACA,OACA,WACA,aACA,eACA,WACA,MACA,UACA,eAEA,OAIA,CACA,iBACA,mBACA,GAIA,CACA,WACA,QACA,WACA,eACA,kBACA,YACA,WACA,iBACA,EACA,UACA,kBACA,UACC,aAED,CAIA,gBAeA,YAdA,CACA,aACA,eACA,OACA,YACA,SACA,QACA,OACA,OAIA,WAiBA,YAXA,SAGA,WAIA,gBAAsB,0BAGtB,WAKA,CACA,YAEA,YACA,SAEG,UACH,OACA,uBACA,KAEA,CAIA,CACA,WAA6B,iCAAyC,MAEtE,YACA,SAEG,UAEH,OACA,oBACA,mBAGA,kBACA,cACK,UAEL,YACA,SACA,CACA,QACA,OACA,OACA,SACA,kBACA,MAKA,iBAQA,YANA,YACA,OACA,OACA,OAEA,MAGA,sCAxLA,IA0LA,+CAEA,cAEA,WACA,kBACA,qCACA,qBAEA,SAAW,OAAY,UACvB,4BACA,cAGA,kCAAkD,KAElD,WACA,OAKA,gBACA,SAEA,MACA,QAIA,eAZA,aACA,aAEA,UAWA,cAEA,CAGA,WACA,YAGA,YACA,+BACA,SACA,SACA,CACA,QACA,OACA,QACA,sBACA,OACA,QACA,oBAEA,UACA,SACA,CAEA,WAEA,kDAKA,KACA,OACA,OACA,OACA,OAEA,WACA,YAEA,MACA,KACA,0CAEA,IAEA,IACA,wCAEA,KAEA,UAGA,YACA,IAEA,MACA,sDACA,CACA,IACA,oDACA,CACA,IACA,mDACA,CACA,IAEA,EAAC,GAED,GACA,QACA,OACA,OACA,OACA,8CClSA,WAEA,gBAEA,iBAEA,mFACA,QAAyB,GACzB,aAAyB,GACzB,cAAyB,OACzB,eAAyB,QACzB,YAAmC,cACnC,2CAGA,gBAEA,UACA,oBAnBA,kCC2DA,mBA6BA,6BACA,+BACA,YAGA,gBAA0B,gBAAU,WACpC,SACA,cACA,mBACA,qBACA,2BACA,IAEA,oBAhGA,WAEA,WAEA,oBAEA,WACA,mDAEA,OACA,MACA,+CAIA,mDAEA,OACA,aAGA,kDASA,MAdA,EAUA,2BAKA,MACA,UACA,eACA,gCACA,iCAEG,mDAEH,6BACA,UACA,WAEA,KACA,mBACA,QACA,SACA,EAIA,gBACA,4BA7DuB,IAEvB,4BAMA,kBCVA,WAAkB,2EAAqF,8zBAAm5B,sFAAe,eAA4D,0FAAuD,IAAkD,8GAAsE,oBAA8G,wGAAoB,+8BAAq+B,yBAAiB,0U,0CCe52E,eACA,GACA,uBACA,wBAEA,oBADA,gBASA,CA5BA,IA6BA,aAEA,6DACA,cACA,KACA,mBACA,kBACA,OAEA,sCAGA,iEACA,UACA,aACA,OACA,MACA,UACA,eACA,YACA,gBAIA,0EACA,KAQA,uBAPA,qDACA,4CACA,6BACA,YACA,iBAEA,0BAxDA,IACA,QAQA,kCC8GA,mBAGA,SAGA,kCACA,UACA,kBAAoB,GACpB,aAAoB,GACpB,cAAoB,KACpB,eAAoB,KACpB,gBACA,mBACG,SACH,GACA,IAGA,UACA,UAtIA,WAEA,kBAGA,mCACA,oBACA,YACA,iBACA,iBACA,iBAEA,sBACA,eACA,eACA,eAEA,eAGA,kBACA,cACA,cACA,cASA,mEACA,WACA,QACA,eAEA,2BACA,4CAEA,eAEA,0DAEA,sCACA,6DACA,gBACA,SAGA,mBACA,MACA,YAEA,4DACA,qCACA,iCACA,yBACA,yBACA,KAEA,2EACA,iBACA,QAEA,oBACA,cAGA,4BAGA,4DACA,cACA,QAAiB,IAAK,IAAG,IAAK,MAAK,GAAU,IAAG,GAAU,IAAG,IAAK,IAAG,IACrE,SAEA,4BAKA,2EACA,cACA,QAAuB,IAAK,IAAG,IAAK,MAAK,GAAU,IAAG,GAAU,IAAG,IAAK,IAAG,IAC3E,YACA,kBACA,OACA,aAIA,4CACA,sDAAgD,SAIhD,KACA,uDAAkD,SAGlD,OAEA,uCACA,UACA,eACA,OACA,aACG,qBACH,0BAEA,YACA,4BAjHA,sCCHA,SAAiC,+BAAkC,SAGnE,CACA,mCACA,eACA,eAGA,aACA,KAuBA,SAtBA,cACA,mBACA,mBACA,SAEA,UACA,SAKA,gBACA,oBACA,wCAGA,cAGA,aAAoB,0BAEpB,4BAjCA,mBCLA,aAGA,aAEA,OAKA,gEACA,iBAEA,iBACA,kBAKA,cAIA,CACA,YACA,QACA,oBACA,wCAEA,uCACA,8DACA,aACA,gBAIA,CACA,YACA,yBACA,2BAMA,CA3CA,IA4CA,UACA,aAEA,oDACA,wCACA,uCACA,qCAEA,eACA,cACA,sBACA,wGC9CA,IAsPA,IArPA,KAKA,cACA,aACA,IAKA,OACA,UACA,WACA,oBAKA,UACA,UACA,cACA,oBAKA,UACA,aACA,uDACA,uBACA,IAKA,oBACA,OACA,GAEA,+BADA,UAMA,yBACA,+CACA,SAKA,YAEA,aACA,KAMA,6BALA,GACA,WAEA,IACA,IAQA,aAAgB,uBAA8B,YAC9C,gBACA,yBACA,cAEA,kBACA,UACA,WAEA,iBACA,WACA,kCACA,iBACA,KACA,aACW,wCACX,oCAKS,4BACT,GACA,UACA,WACA,gBAEA,EAEA,YACA,aACA,2CACA,CAGA,8CACA,SACA,yBAA0B,gBAC1B,YACA,EACA,EAKA,aAEA,yBAEA,OAGA,SACA,yBAGA,qDAIA,sCAIA,iBAGA,iBAGA,CAGA,IACA,wBAEA,WAGS,YACT,6BAGA,SAGA,kBACA,UACA,QAEA,KACA,OACA,EAKA,uBAEA,kBAIA,SACA,QAIA,aAHA,YAEA,UAGA,SAVA,OAEA,iCAWA,MACA,kCACA,6BAGA,wCAGA,OACA,OAIA,sBAEA,OAGA,QAIA,6BACA,QAEA,2BAEA,WACA,kDACA,QACA,SACA,WAGA,gBAAW,yBAEX,WACA,kDACA,QACA,SACA,WAGA,gBAAW,6BAEX,oBACA,wBACA,eACA,uDACA,QACA,SACA,WAEA,gBACA,kBAEA,gBACA,CAGA,GACA,KACA,EACA,iCCzPA,kBAEA,OAGA,MACA,qCAA6B,SAC7B,qCAAwC,uBACxC,YACA,UACA,oBAKA,sCACA,SACA,iBACA,KAGA,8BAGA,cACA,UAEA,oCAEA,OACA,KACA,2BAAoB,IAAW,QAC/B,eAEK,KACL,2BAAoB,IAAU,OAC9B,cAEK,KACL,aAAoB,IAAK,MAAK,iBAC9B,cAEK,KACL,4BAAqB,KACrB,YACA,mBAEA,IAEA,UACA,KAIA,CAcA,aACA,WACA,mBA9EA,IA+DA,WACA,IACA,YACA,QAAG,SACH,oBACA,wBACA,aACA,IACA,CAIA,UA3EA,QAOA","file":"./dist/pdfanno.core.bundle.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PDFAnnoCore\"] = factory();\n\telse\n\t\troot[\"PDFAnnoCore\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/**\r\n *   The list of functionalities for a relationship between annotations.\r\n */\r\n\r\n/**\r\n * Get bezier control point.\r\n *\r\n * @params x1 : the x of a start position.\r\n * @params y1 : the y of a start position.\r\n * @params x2 : the x of an end position.\r\n * @params y2 : the y of an end position.\r\n * @return { x, y } the position of bezier control.\r\n */\r\nexport function findBezierControlPoint (x1, y1, x2, y2) {\r\n\r\n  const DISTANCE = 30\r\n\r\n  // vertical line.\r\n  if (x1 === x2) {\r\n    return {\r\n      x : x1,\r\n      y : (y1 + y2) / 2\r\n    }\r\n  }\r\n\r\n  // horizontal line.\r\n  if (y1 === y2) {\r\n    return {\r\n      x : (x1 + x2) / 2,\r\n      y : y1 - DISTANCE\r\n    }\r\n  }\r\n\r\n  let center = {\r\n    x : (x1 + x2) / 2,\r\n    y : (y1 + y2) / 2\r\n  }\r\n\r\n  let gradient = (y1 - y2) / (x1 - x2)\r\n  gradient = -1 / gradient\r\n\r\n  let theta = Math.atan(gradient)\r\n  let deltaX = Math.cos(theta) * DISTANCE\r\n  let deltaY = Math.sin(theta) * DISTANCE\r\n\r\n  if (x1 < x2) {\r\n    // right top quadrant.\r\n    if (y1 > y2) {\r\n      return {\r\n        x : center.x - Math.abs(deltaX),\r\n        y : center.y - Math.abs(deltaY)\r\n      }\r\n      // right bottom quadrant.\r\n    } else {\r\n      return {\r\n        x : center.x + Math.abs(deltaX),\r\n        y : center.y - Math.abs(deltaY)\r\n      }\r\n    }\r\n  } else {\r\n    // left top quadrant.\r\n    if (y1 > y2) {\r\n      return {\r\n        x : center.x + Math.abs(deltaX),\r\n        y : center.y - Math.abs(deltaY)\r\n      }\r\n      // left bottom quadrant.\r\n    } else {\r\n      return {\r\n        x : center.x - Math.abs(deltaX),\r\n        y : center.y - Math.abs(deltaY)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function getRelationTextPosition (x1, y1, x2, y2, text = '', parentId = null) {\r\n\r\n  // texts rendered.\r\n  let rects = []\r\n  $('.anno-text').each(function () {\r\n    let $this = $(this)\r\n    // Remove myself.\r\n    if ($this.parent().data('parent-id') !== parentId) {\r\n      rects.push({\r\n        x      : parseFloat($this.attr('x')),\r\n        y      : parseFloat($this.attr('y')),\r\n        width  : parseFloat($this.attr('width')),\r\n        height : parseFloat($this.attr('height'))\r\n      })\r\n    }\r\n  })\r\n\r\n  // Set self size.\r\n  let myWidth = 200\r\n  let myHeight = 15\r\n\r\n  let addY = 5\r\n  if (y1 < y2) {\r\n    addY *= -1\r\n  }\r\n\r\n  // Find the position not overlap.\r\n  while (true) {\r\n\r\n    let cp = findBezierControlPoint(x1, y1, x2, y2)\r\n    let x = x2 + (cp.x - x2) * 0.4\r\n    let y = y2 + (cp.y - y2) * 0.4\r\n\r\n    let ok = true\r\n    for (let i = 0; i < rects.length; i++) {\r\n      let r = rects[i]\r\n\r\n      // Check rects overlap.\r\n\r\n      let aX1 = r.x\r\n      let aX2 = r.x + r.width\r\n      let aY1 = r.y\r\n      let aY2 = r.y + r.height\r\n\r\n      let bX1 = x\r\n      let bX2 = x + myWidth\r\n      let bY1 = y\r\n      let bY2 = y + myHeight\r\n\r\n      let crossX = aX1 <= bX2 && bX1 <= aX2\r\n      let crossY = aY1 <= bY2 && bY1 <= aY2\r\n\r\n      if (crossX && crossY) {\r\n        ok = false\r\n        break\r\n      }\r\n    }\r\n\r\n    if (ok) {\r\n      return { x, y }\r\n    }\r\n\r\n    y1 += addY\r\n    y2 += addY\r\n  }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/utils/relation.js\n// module id = 60\n// module chunks = 2"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 70);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 02b50d569d092c71ef71","/**\r\n * Convert the `y` position from the local coords to exported json.\r\n */\r\nexport function convertToExportY (y) {\r\n\r\n  let meta = getPageSize()\r\n\r\n  y -= paddingTop\r\n\r\n  let pageHeight = meta.height + paddingBetweenPages\r\n\r\n  let pageNumber = Math.floor(y / pageHeight) + 1\r\n  let yInPage = y - (pageNumber - 1) * pageHeight\r\n\r\n  return { pageNumber, y : yInPage }\r\n}\r\n\r\n/**\r\n * Convert the `y` position from exported json to local coords.\r\n */\r\nexport function convertFromExportY (pageNumber, yInPage) {\r\n\r\n  let meta = getPageSize()\r\n\r\n  let y = yInPage + paddingTop\r\n\r\n  let pagePadding = paddingBetweenPages\r\n\r\n  y += (pageNumber - 1) * (meta.height + pagePadding)\r\n\r\n  return y\r\n}\r\n\r\n/**\r\n * The padding of page top.\r\n */\r\nconst paddingTop = 9\r\n\r\n/**\r\n * The padding between pages.\r\n */\r\nexport const paddingBetweenPages = 9\r\n\r\n/**\r\n * Get a page size of a single PDF page.\r\n */\r\nexport function getPageSize () {\r\n\r\n  let pdfView = window.PDFView || window.iframeWindow.PDFView\r\n\r\n  let viewBox = pdfView.pdfViewer.getPageView(0).viewport.viewBox\r\n  let size = { width : viewBox[2], height : viewBox[3] }\r\n  return size\r\n}\r\n\r\n/**\r\n * Get the next z-index.\r\n */\r\nexport function nextZIndex () {\r\n\r\n  let w = (window.iframeWindow ? window.iframeWindow : window)\r\n\r\n  if (!w.nextZIndex) {\r\n    w.nextZIndex = 10\r\n  }\r\n\r\n  return w.nextZIndex++\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/shared/coords.js\n// module id = 1\n// module chunks = 0 1 2","/**\r\n * Utility.\r\n */\r\n\r\nexport function anyOf (target, candidates) {\r\n  return candidates.filter(c => c === target).length > 0\r\n}\r\n\r\n/**\r\n * Dispatch a custom event to `window` object.\r\n */\r\nexport function dispatchWindowEvent (eventName, data) {\r\n  var event = document.createEvent('CustomEvent')\r\n  event.initCustomEvent(eventName, true, true, data)\r\n  window.dispatchEvent(event)\r\n}\r\n\r\n/**\r\n * Parse URL queries, and return it as a Map.\r\n * @returns {{}}\r\n */\r\n// TODO make as common?\r\nexport function parseUrlQuery () {\r\n  return window.location.search\r\n    .replace('?', '')\r\n    .split('&')\r\n    .reduce((map, keyValue) => {\r\n      const [ key, value ] = keyValue.split('=')\r\n      map[key] = value\r\n      return map\r\n    }, {})\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/shared/util.js\n// module id = 3\n// module chunks = 0 1 2","/**\r\n * Make the UI resizable.\r\n */\r\nexport function setupResizableColumns () {\r\n    // Make resizable.\r\n    $('#tools').resizable({\r\n        handles           : 'e',\r\n        alsoResizeReverse : '#viewerWrapper',\r\n        start             : () => {\r\n            $('#viewer iframe').css({\r\n                'pointer-events' : 'none'\r\n            })\r\n        },\r\n        stop : () => {\r\n            $('#viewer iframe').css({\r\n                'pointer-events' : 'auto'\r\n            })\r\n        }\r\n    })\r\n\r\n    // Customize.\r\n    $.ui.plugin.add('resizable', 'alsoResizeReverse', {\r\n\r\n        start : function () {\r\n            let that = $(this).resizable('instance')\r\n            let o = that.options\r\n\r\n            $(o.alsoResizeReverse).each(function () {\r\n                var el = $(this)\r\n                el.data('ui-resizable-alsoresizeReverse', {\r\n                    width  : parseInt(el.width(), 10),\r\n                    height : parseInt(el.height(), 10),\r\n                    left   : parseInt(el.css('left'), 10),\r\n                    top    : parseInt(el.css('top'), 10)\r\n                })\r\n            })\r\n        },\r\n\r\n        resize : function (event, ui) {\r\n            let that = $(this).resizable('instance')\r\n            let o = that.options\r\n            let os = that.originalSize\r\n            let op = that.originalPosition\r\n            let delta = {\r\n                height : (that.size.height - os.height) || 0,\r\n                width  : (that.size.width - os.width) || 0,\r\n                top    : (that.position.top - op.top) || 0,\r\n                left   : (that.position.left - op.left) || 0\r\n            }\r\n\r\n            $(o.alsoResizeReverse).each(function () {\r\n                let el = $(this)\r\n                let start = $(this).data('ui-resizable-alsoresize-reverse')\r\n                let style = {}\r\n                let css = el.parents(ui.originalElement[0]).length\r\n                        ? [ 'width', 'height' ]\r\n                        : [ 'width', 'height', 'top', 'left' ]\r\n\r\n                $.each(css, function (i, prop) {\r\n                    let sum = (start[prop] || 0) - (delta[prop] || 0)\r\n                    if (sum && sum >= 0) {\r\n                        style[prop] = sum || null\r\n                    }\r\n                })\r\n\r\n                el.css(style)\r\n            })\r\n        },\r\n\r\n        stop : function () {\r\n            $(this).removeData('resizable-alsoresize-reverse')\r\n        }\r\n    })\r\n}\r\n\r\n/**\r\n * Convert object to TOML String.\r\n */\r\nexport function tomlString (obj, root = true) {\r\n    let lines = []\r\n\r\n    // `version` is first.\r\n    if ('version' in obj) {\r\n        lines.push(`version = \"${obj['version']}\"`)\r\n        lines.push('')\r\n        delete obj['version']\r\n    }\r\n\r\n    // #paperanno-ja/issues/38\r\n    // Make all values in `position` as string.\r\n    if ('position' in obj) {\r\n        let position = obj.position\r\n        position = position.map(p => {\r\n            if (typeof p === 'number') {\r\n                return String(p)\r\n            } else {\r\n                return p.map(v => String(v))\r\n            }\r\n        })\r\n        obj.position = position\r\n    }\r\n\r\n    Object.keys(obj).forEach(prop => {\r\n        let val = obj[prop]\r\n        if (typeof val === 'string') {\r\n            lines.push(`${prop} = \"${val}\"`)\r\n            root && lines.push('')\r\n        } else if (typeof val === 'number') {\r\n            lines.push(`${prop} = ${val}`)\r\n            root && lines.push('')\r\n        } else if (isArray(val)) {\r\n            lines.push(`${prop} = ${JSON.stringify(val)}`)\r\n            root && lines.push('')\r\n        } else if (typeof val === 'object') {\r\n            lines.push(`[${prop}]`)\r\n            lines.push(tomlString(val, false))\r\n            root && lines.push('')\r\n        }\r\n    })\r\n\r\n    return lines.join('\\n')\r\n}\r\n\r\n/**\r\n * Check the value is array.\r\n */\r\nfunction isArray (val) {\r\n    return val && 'length' in val\r\n}\r\n\r\n/**\r\n * Generate a universally unique identifier\r\n *\r\n * @return {String}\r\n */\r\nexport function uuid (len = 8) {\r\n\r\n    // Length of ID characters.\r\n    const ID_LENGTH = len\r\n\r\n    // Candidates.\r\n    const BASE = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\r\n\r\n    // The number of candidates.\r\n    const BASE_LEN = BASE.length\r\n\r\n    let id = ''\r\n    for (let i = 0; i < ID_LENGTH; i++) {\r\n        id += BASE[ Math.floor(Math.random() * BASE_LEN) ]\r\n    }\r\n    return id\r\n}\r\n\r\n/**\r\n * Download a content with the fileName.\r\n */\r\nexport function download (fileName, content) {\r\n    let blob = new Blob([content])\r\n    let blobURL = window.URL.createObjectURL(blob)\r\n    let a = document.createElement('a')\r\n    document.body.appendChild(a) // for Firefox working correctly.\r\n    a.download = fileName\r\n    a.href = blobURL\r\n    a.click()\r\n    a.parentNode.removeChild(a)\r\n}\r\n\r\n/**\r\n * Load a file as a text.\r\n */\r\nexport function loadFileAsText (file) {\r\n    return new Promise((resolve, reject) => {\r\n        let fileReader = new FileReader()\r\n        fileReader.onload = event => {\r\n            const text = event.target.result\r\n            resolve(text)\r\n        }\r\n        fileReader.onerror = err => {\r\n            reject(err)\r\n        }\r\n        fileReader.readAsText(file)\r\n    })\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/anno-ui/src/utils/index.js\n// module id = 4\n// module chunks = 0 1 2","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader/lib/css-base.js\n// module id = 5\n// module chunks = 0 1 2 3","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(self.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement(\"link\");\n\tlinkElement.rel = \"stylesheet\";\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute(\"media\", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/style-loader/addStyles.js\n// module id = 6\n// module chunks = 0 1 2 3","var parser = require('./lib/parser');\r\nvar compiler = require('./lib/compiler');\r\n\r\nmodule.exports = {\r\n  parse: function(input) {\r\n    var nodes = parser.parse(input.toString());\r\n    return compiler.compile(nodes);\r\n  }\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/toml/index.js\n// module id = 12\n// module chunks = 0 1 2","module.exports = (function() {\r\n  /*\r\n   * Generated by PEG.js 0.8.0.\r\n   *\r\n   * http://pegjs.majda.cz/\r\n   */\r\n\r\n  function peg$subclass(child, parent) {\r\n    function ctor() { this.constructor = child; }\r\n    ctor.prototype = parent.prototype;\r\n    child.prototype = new ctor();\r\n  }\r\n\r\n  function SyntaxError(message, expected, found, offset, line, column) {\r\n    this.message  = message;\r\n    this.expected = expected;\r\n    this.found    = found;\r\n    this.offset   = offset;\r\n    this.line     = line;\r\n    this.column   = column;\r\n\r\n    this.name     = \"SyntaxError\";\r\n  }\r\n\r\n  peg$subclass(SyntaxError, Error);\r\n\r\n  function parse(input) {\r\n    var options = arguments.length > 1 ? arguments[1] : {},\r\n\r\n        peg$FAILED = {},\r\n\r\n        peg$startRuleFunctions = { start: peg$parsestart },\r\n        peg$startRuleFunction  = peg$parsestart,\r\n\r\n        peg$c0 = [],\r\n        peg$c1 = function() { return nodes },\r\n        peg$c2 = peg$FAILED,\r\n        peg$c3 = \"#\",\r\n        peg$c4 = { type: \"literal\", value: \"#\", description: \"\\\"#\\\"\" },\r\n        peg$c5 = void 0,\r\n        peg$c6 = { type: \"any\", description: \"any character\" },\r\n        peg$c7 = \"[\",\r\n        peg$c8 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\r\n        peg$c9 = \"]\",\r\n        peg$c10 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\r\n        peg$c11 = function(name) { addNode(node('ObjectPath', name, line, column)) },\r\n        peg$c12 = function(name) { addNode(node('ArrayPath', name, line, column)) },\r\n        peg$c13 = function(parts, name) { return parts.concat(name) },\r\n        peg$c14 = function(name) { return [name] },\r\n        peg$c15 = function(name) { return name },\r\n        peg$c16 = \".\",\r\n        peg$c17 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\r\n        peg$c18 = \"=\",\r\n        peg$c19 = { type: \"literal\", value: \"=\", description: \"\\\"=\\\"\" },\r\n        peg$c20 = function(key, value) { addNode(node('Assign', value, line, column, key)) },\r\n        peg$c21 = function(chars) { return chars.join('') },\r\n        peg$c22 = function(node) { return node.value },\r\n        peg$c23 = \"\\\"\\\"\\\"\",\r\n        peg$c24 = { type: \"literal\", value: \"\\\"\\\"\\\"\", description: \"\\\"\\\\\\\"\\\\\\\"\\\\\\\"\\\"\" },\r\n        peg$c25 = null,\r\n        peg$c26 = function(chars) { return node('String', chars.join(''), line, column) },\r\n        peg$c27 = \"\\\"\",\r\n        peg$c28 = { type: \"literal\", value: \"\\\"\", description: \"\\\"\\\\\\\"\\\"\" },\r\n        peg$c29 = \"'''\",\r\n        peg$c30 = { type: \"literal\", value: \"'''\", description: \"\\\"'''\\\"\" },\r\n        peg$c31 = \"'\",\r\n        peg$c32 = { type: \"literal\", value: \"'\", description: \"\\\"'\\\"\" },\r\n        peg$c33 = function(char) { return char },\r\n        peg$c34 = function(char) { return char},\r\n        peg$c35 = \"\\\\\",\r\n        peg$c36 = { type: \"literal\", value: \"\\\\\", description: \"\\\"\\\\\\\\\\\"\" },\r\n        peg$c37 = function() { return '' },\r\n        peg$c38 = \"e\",\r\n        peg$c39 = { type: \"literal\", value: \"e\", description: \"\\\"e\\\"\" },\r\n        peg$c40 = \"E\",\r\n        peg$c41 = { type: \"literal\", value: \"E\", description: \"\\\"E\\\"\" },\r\n        peg$c42 = function(left, right) { return node('Float', parseFloat(left + 'e' + right), line, column) },\r\n        peg$c43 = function(text) { return node('Float', parseFloat(text), line, column) },\r\n        peg$c44 = \"+\",\r\n        peg$c45 = { type: \"literal\", value: \"+\", description: \"\\\"+\\\"\" },\r\n        peg$c46 = function(digits) { return digits.join('') },\r\n        peg$c47 = \"-\",\r\n        peg$c48 = { type: \"literal\", value: \"-\", description: \"\\\"-\\\"\" },\r\n        peg$c49 = function(digits) { return '-' + digits.join('') },\r\n        peg$c50 = function(text) { return node('Integer', parseInt(text, 10), line, column) },\r\n        peg$c51 = \"true\",\r\n        peg$c52 = { type: \"literal\", value: \"true\", description: \"\\\"true\\\"\" },\r\n        peg$c53 = function() { return node('Boolean', true, line, column) },\r\n        peg$c54 = \"false\",\r\n        peg$c55 = { type: \"literal\", value: \"false\", description: \"\\\"false\\\"\" },\r\n        peg$c56 = function() { return node('Boolean', false, line, column) },\r\n        peg$c57 = function() { return node('Array', [], line, column) },\r\n        peg$c58 = function(value) { return node('Array', value ? [value] : [], line, column) },\r\n        peg$c59 = function(values) { return node('Array', values, line, column) },\r\n        peg$c60 = function(values, value) { return node('Array', values.concat(value), line, column) },\r\n        peg$c61 = function(value) { return value },\r\n        peg$c62 = \",\",\r\n        peg$c63 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\r\n        peg$c64 = \"{\",\r\n        peg$c65 = { type: \"literal\", value: \"{\", description: \"\\\"{\\\"\" },\r\n        peg$c66 = \"}\",\r\n        peg$c67 = { type: \"literal\", value: \"}\", description: \"\\\"}\\\"\" },\r\n        peg$c68 = function(values) { return node('InlineTable', values, line, column) },\r\n        peg$c69 = function(key, value) { return node('InlineTableValue', value, line, column, key) },\r\n        peg$c70 = function(digits) { return \".\" + digits },\r\n        peg$c71 = function(date) { return  date.join('') },\r\n        peg$c72 = \":\",\r\n        peg$c73 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\r\n        peg$c74 = function(time) { return time.join('') },\r\n        peg$c75 = \"T\",\r\n        peg$c76 = { type: \"literal\", value: \"T\", description: \"\\\"T\\\"\" },\r\n        peg$c77 = \"Z\",\r\n        peg$c78 = { type: \"literal\", value: \"Z\", description: \"\\\"Z\\\"\" },\r\n        peg$c79 = function(date, time) { return node('Date', new Date(date + \"T\" + time + \"Z\"), line, column) },\r\n        peg$c80 = function(date, time) { return node('Date', new Date(date + \"T\" + time), line, column) },\r\n        peg$c81 = /^[ \\t]/,\r\n        peg$c82 = { type: \"class\", value: \"[ \\\\t]\", description: \"[ \\\\t]\" },\r\n        peg$c83 = \"\\n\",\r\n        peg$c84 = { type: \"literal\", value: \"\\n\", description: \"\\\"\\\\n\\\"\" },\r\n        peg$c85 = \"\\r\",\r\n        peg$c86 = { type: \"literal\", value: \"\\r\", description: \"\\\"\\\\r\\\"\" },\r\n        peg$c87 = /^[0-9a-f]/i,\r\n        peg$c88 = { type: \"class\", value: \"[0-9a-f]i\", description: \"[0-9a-f]i\" },\r\n        peg$c89 = /^[0-9]/,\r\n        peg$c90 = { type: \"class\", value: \"[0-9]\", description: \"[0-9]\" },\r\n        peg$c91 = \"_\",\r\n        peg$c92 = { type: \"literal\", value: \"_\", description: \"\\\"_\\\"\" },\r\n        peg$c93 = function() { return \"\" },\r\n        peg$c94 = /^[A-Za-z0-9_\\-]/,\r\n        peg$c95 = { type: \"class\", value: \"[A-Za-z0-9_\\\\-]\", description: \"[A-Za-z0-9_\\\\-]\" },\r\n        peg$c96 = function(d) { return d.join('') },\r\n        peg$c97 = \"\\\\\\\"\",\r\n        peg$c98 = { type: \"literal\", value: \"\\\\\\\"\", description: \"\\\"\\\\\\\\\\\\\\\"\\\"\" },\r\n        peg$c99 = function() { return '\"'  },\r\n        peg$c100 = \"\\\\\\\\\",\r\n        peg$c101 = { type: \"literal\", value: \"\\\\\\\\\", description: \"\\\"\\\\\\\\\\\\\\\\\\\"\" },\r\n        peg$c102 = function() { return '\\\\' },\r\n        peg$c103 = \"\\\\b\",\r\n        peg$c104 = { type: \"literal\", value: \"\\\\b\", description: \"\\\"\\\\\\\\b\\\"\" },\r\n        peg$c105 = function() { return '\\b' },\r\n        peg$c106 = \"\\\\t\",\r\n        peg$c107 = { type: \"literal\", value: \"\\\\t\", description: \"\\\"\\\\\\\\t\\\"\" },\r\n        peg$c108 = function() { return '\\t' },\r\n        peg$c109 = \"\\\\n\",\r\n        peg$c110 = { type: \"literal\", value: \"\\\\n\", description: \"\\\"\\\\\\\\n\\\"\" },\r\n        peg$c111 = function() { return '\\n' },\r\n        peg$c112 = \"\\\\f\",\r\n        peg$c113 = { type: \"literal\", value: \"\\\\f\", description: \"\\\"\\\\\\\\f\\\"\" },\r\n        peg$c114 = function() { return '\\f' },\r\n        peg$c115 = \"\\\\r\",\r\n        peg$c116 = { type: \"literal\", value: \"\\\\r\", description: \"\\\"\\\\\\\\r\\\"\" },\r\n        peg$c117 = function() { return '\\r' },\r\n        peg$c118 = \"\\\\U\",\r\n        peg$c119 = { type: \"literal\", value: \"\\\\U\", description: \"\\\"\\\\\\\\U\\\"\" },\r\n        peg$c120 = function(digits) { return convertCodePoint(digits.join('')) },\r\n        peg$c121 = \"\\\\u\",\r\n        peg$c122 = { type: \"literal\", value: \"\\\\u\", description: \"\\\"\\\\\\\\u\\\"\" },\r\n\r\n        peg$currPos          = 0,\r\n        peg$reportedPos      = 0,\r\n        peg$cachedPos        = 0,\r\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\r\n        peg$maxFailPos       = 0,\r\n        peg$maxFailExpected  = [],\r\n        peg$silentFails      = 0,\r\n\r\n        peg$cache = {},\r\n        peg$result;\r\n\r\n    if (\"startRule\" in options) {\r\n      if (!(options.startRule in peg$startRuleFunctions)) {\r\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\r\n      }\r\n\r\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\r\n    }\r\n\r\n    function text() {\r\n      return input.substring(peg$reportedPos, peg$currPos);\r\n    }\r\n\r\n    function offset() {\r\n      return peg$reportedPos;\r\n    }\r\n\r\n    function line() {\r\n      return peg$computePosDetails(peg$reportedPos).line;\r\n    }\r\n\r\n    function column() {\r\n      return peg$computePosDetails(peg$reportedPos).column;\r\n    }\r\n\r\n    function expected(description) {\r\n      throw peg$buildException(\r\n        null,\r\n        [{ type: \"other\", description: description }],\r\n        peg$reportedPos\r\n      );\r\n    }\r\n\r\n    function error(message) {\r\n      throw peg$buildException(message, null, peg$reportedPos);\r\n    }\r\n\r\n    function peg$computePosDetails(pos) {\r\n      function advance(details, startPos, endPos) {\r\n        var p, ch;\r\n\r\n        for (p = startPos; p < endPos; p++) {\r\n          ch = input.charAt(p);\r\n          if (ch === \"\\n\") {\r\n            if (!details.seenCR) { details.line++; }\r\n            details.column = 1;\r\n            details.seenCR = false;\r\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\r\n            details.line++;\r\n            details.column = 1;\r\n            details.seenCR = true;\r\n          } else {\r\n            details.column++;\r\n            details.seenCR = false;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (peg$cachedPos !== pos) {\r\n        if (peg$cachedPos > pos) {\r\n          peg$cachedPos = 0;\r\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\r\n        }\r\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\r\n        peg$cachedPos = pos;\r\n      }\r\n\r\n      return peg$cachedPosDetails;\r\n    }\r\n\r\n    function peg$fail(expected) {\r\n      if (peg$currPos < peg$maxFailPos) { return; }\r\n\r\n      if (peg$currPos > peg$maxFailPos) {\r\n        peg$maxFailPos = peg$currPos;\r\n        peg$maxFailExpected = [];\r\n      }\r\n\r\n      peg$maxFailExpected.push(expected);\r\n    }\r\n\r\n    function peg$buildException(message, expected, pos) {\r\n      function cleanupExpected(expected) {\r\n        var i = 1;\r\n\r\n        expected.sort(function(a, b) {\r\n          if (a.description < b.description) {\r\n            return -1;\r\n          } else if (a.description > b.description) {\r\n            return 1;\r\n          } else {\r\n            return 0;\r\n          }\r\n        });\r\n\r\n        while (i < expected.length) {\r\n          if (expected[i - 1] === expected[i]) {\r\n            expected.splice(i, 1);\r\n          } else {\r\n            i++;\r\n          }\r\n        }\r\n      }\r\n\r\n      function buildMessage(expected, found) {\r\n        function stringEscape(s) {\r\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\r\n\r\n          return s\r\n            .replace(/\\\\/g,   '\\\\\\\\')\r\n            .replace(/\"/g,    '\\\\\"')\r\n            .replace(/\\x08/g, '\\\\b')\r\n            .replace(/\\t/g,   '\\\\t')\r\n            .replace(/\\n/g,   '\\\\n')\r\n            .replace(/\\f/g,   '\\\\f')\r\n            .replace(/\\r/g,   '\\\\r')\r\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\r\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\r\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\r\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\r\n        }\r\n\r\n        var expectedDescs = new Array(expected.length),\r\n            expectedDesc, foundDesc, i;\r\n\r\n        for (i = 0; i < expected.length; i++) {\r\n          expectedDescs[i] = expected[i].description;\r\n        }\r\n\r\n        expectedDesc = expected.length > 1\r\n          ? expectedDescs.slice(0, -1).join(\", \")\r\n              + \" or \"\r\n              + expectedDescs[expected.length - 1]\r\n          : expectedDescs[0];\r\n\r\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\r\n\r\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\r\n      }\r\n\r\n      var posDetails = peg$computePosDetails(pos),\r\n          found      = pos < input.length ? input.charAt(pos) : null;\r\n\r\n      if (expected !== null) {\r\n        cleanupExpected(expected);\r\n      }\r\n\r\n      return new SyntaxError(\r\n        message !== null ? message : buildMessage(expected, found),\r\n        expected,\r\n        found,\r\n        pos,\r\n        posDetails.line,\r\n        posDetails.column\r\n      );\r\n    }\r\n\r\n    function peg$parsestart() {\r\n      var s0, s1, s2;\r\n\r\n      var key    = peg$currPos * 49 + 0,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = [];\r\n      s2 = peg$parseline();\r\n      while (s2 !== peg$FAILED) {\r\n        s1.push(s2);\r\n        s2 = peg$parseline();\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        peg$reportedPos = s0;\r\n        s1 = peg$c1();\r\n      }\r\n      s0 = s1;\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseline() {\r\n      var s0, s1, s2, s3, s4, s5, s6;\r\n\r\n      var key    = peg$currPos * 49 + 1,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = [];\r\n      s2 = peg$parseS();\r\n      while (s2 !== peg$FAILED) {\r\n        s1.push(s2);\r\n        s2 = peg$parseS();\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = peg$parseexpression();\r\n        if (s2 !== peg$FAILED) {\r\n          s3 = [];\r\n          s4 = peg$parseS();\r\n          while (s4 !== peg$FAILED) {\r\n            s3.push(s4);\r\n            s4 = peg$parseS();\r\n          }\r\n          if (s3 !== peg$FAILED) {\r\n            s4 = [];\r\n            s5 = peg$parsecomment();\r\n            while (s5 !== peg$FAILED) {\r\n              s4.push(s5);\r\n              s5 = peg$parsecomment();\r\n            }\r\n            if (s4 !== peg$FAILED) {\r\n              s5 = [];\r\n              s6 = peg$parseNL();\r\n              if (s6 !== peg$FAILED) {\r\n                while (s6 !== peg$FAILED) {\r\n                  s5.push(s6);\r\n                  s6 = peg$parseNL();\r\n                }\r\n              } else {\r\n                s5 = peg$c2;\r\n              }\r\n              if (s5 === peg$FAILED) {\r\n                s5 = peg$parseEOF();\r\n              }\r\n              if (s5 !== peg$FAILED) {\r\n                s1 = [s1, s2, s3, s4, s5];\r\n                s0 = s1;\r\n              } else {\r\n                peg$currPos = s0;\r\n                s0 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$currPos;\r\n        s1 = [];\r\n        s2 = peg$parseS();\r\n        if (s2 !== peg$FAILED) {\r\n          while (s2 !== peg$FAILED) {\r\n            s1.push(s2);\r\n            s2 = peg$parseS();\r\n          }\r\n        } else {\r\n          s1 = peg$c2;\r\n        }\r\n        if (s1 !== peg$FAILED) {\r\n          s2 = [];\r\n          s3 = peg$parseNL();\r\n          if (s3 !== peg$FAILED) {\r\n            while (s3 !== peg$FAILED) {\r\n              s2.push(s3);\r\n              s3 = peg$parseNL();\r\n            }\r\n          } else {\r\n            s2 = peg$c2;\r\n          }\r\n          if (s2 === peg$FAILED) {\r\n            s2 = peg$parseEOF();\r\n          }\r\n          if (s2 !== peg$FAILED) {\r\n            s1 = [s1, s2];\r\n            s0 = s1;\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n        if (s0 === peg$FAILED) {\r\n          s0 = peg$parseNL();\r\n        }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseexpression() {\r\n      var s0;\r\n\r\n      var key    = peg$currPos * 49 + 2,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$parsecomment();\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$parsepath();\r\n        if (s0 === peg$FAILED) {\r\n          s0 = peg$parsetablearray();\r\n          if (s0 === peg$FAILED) {\r\n            s0 = peg$parseassignment();\r\n          }\r\n        }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsecomment() {\r\n      var s0, s1, s2, s3, s4, s5;\r\n\r\n      var key    = peg$currPos * 49 + 3,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      if (input.charCodeAt(peg$currPos) === 35) {\r\n        s1 = peg$c3;\r\n        peg$currPos++;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c4); }\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = [];\r\n        s3 = peg$currPos;\r\n        s4 = peg$currPos;\r\n        peg$silentFails++;\r\n        s5 = peg$parseNL();\r\n        if (s5 === peg$FAILED) {\r\n          s5 = peg$parseEOF();\r\n        }\r\n        peg$silentFails--;\r\n        if (s5 === peg$FAILED) {\r\n          s4 = peg$c5;\r\n        } else {\r\n          peg$currPos = s4;\r\n          s4 = peg$c2;\r\n        }\r\n        if (s4 !== peg$FAILED) {\r\n          if (input.length > peg$currPos) {\r\n            s5 = input.charAt(peg$currPos);\r\n            peg$currPos++;\r\n          } else {\r\n            s5 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$c6); }\r\n          }\r\n          if (s5 !== peg$FAILED) {\r\n            s4 = [s4, s5];\r\n            s3 = s4;\r\n          } else {\r\n            peg$currPos = s3;\r\n            s3 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s3;\r\n          s3 = peg$c2;\r\n        }\r\n        while (s3 !== peg$FAILED) {\r\n          s2.push(s3);\r\n          s3 = peg$currPos;\r\n          s4 = peg$currPos;\r\n          peg$silentFails++;\r\n          s5 = peg$parseNL();\r\n          if (s5 === peg$FAILED) {\r\n            s5 = peg$parseEOF();\r\n          }\r\n          peg$silentFails--;\r\n          if (s5 === peg$FAILED) {\r\n            s4 = peg$c5;\r\n          } else {\r\n            peg$currPos = s4;\r\n            s4 = peg$c2;\r\n          }\r\n          if (s4 !== peg$FAILED) {\r\n            if (input.length > peg$currPos) {\r\n              s5 = input.charAt(peg$currPos);\r\n              peg$currPos++;\r\n            } else {\r\n              s5 = peg$FAILED;\r\n              if (peg$silentFails === 0) { peg$fail(peg$c6); }\r\n            }\r\n            if (s5 !== peg$FAILED) {\r\n              s4 = [s4, s5];\r\n              s3 = s4;\r\n            } else {\r\n              peg$currPos = s3;\r\n              s3 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s3;\r\n            s3 = peg$c2;\r\n          }\r\n        }\r\n        if (s2 !== peg$FAILED) {\r\n          s1 = [s1, s2];\r\n          s0 = s1;\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsepath() {\r\n      var s0, s1, s2, s3, s4, s5;\r\n\r\n      var key    = peg$currPos * 49 + 4,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      if (input.charCodeAt(peg$currPos) === 91) {\r\n        s1 = peg$c7;\r\n        peg$currPos++;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c8); }\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = [];\r\n        s3 = peg$parseS();\r\n        while (s3 !== peg$FAILED) {\r\n          s2.push(s3);\r\n          s3 = peg$parseS();\r\n        }\r\n        if (s2 !== peg$FAILED) {\r\n          s3 = peg$parsetable_key();\r\n          if (s3 !== peg$FAILED) {\r\n            s4 = [];\r\n            s5 = peg$parseS();\r\n            while (s5 !== peg$FAILED) {\r\n              s4.push(s5);\r\n              s5 = peg$parseS();\r\n            }\r\n            if (s4 !== peg$FAILED) {\r\n              if (input.charCodeAt(peg$currPos) === 93) {\r\n                s5 = peg$c9;\r\n                peg$currPos++;\r\n              } else {\r\n                s5 = peg$FAILED;\r\n                if (peg$silentFails === 0) { peg$fail(peg$c10); }\r\n              }\r\n              if (s5 !== peg$FAILED) {\r\n                peg$reportedPos = s0;\r\n                s1 = peg$c11(s3);\r\n                s0 = s1;\r\n              } else {\r\n                peg$currPos = s0;\r\n                s0 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsetablearray() {\r\n      var s0, s1, s2, s3, s4, s5, s6, s7;\r\n\r\n      var key    = peg$currPos * 49 + 5,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      if (input.charCodeAt(peg$currPos) === 91) {\r\n        s1 = peg$c7;\r\n        peg$currPos++;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c8); }\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        if (input.charCodeAt(peg$currPos) === 91) {\r\n          s2 = peg$c7;\r\n          peg$currPos++;\r\n        } else {\r\n          s2 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\r\n        }\r\n        if (s2 !== peg$FAILED) {\r\n          s3 = [];\r\n          s4 = peg$parseS();\r\n          while (s4 !== peg$FAILED) {\r\n            s3.push(s4);\r\n            s4 = peg$parseS();\r\n          }\r\n          if (s3 !== peg$FAILED) {\r\n            s4 = peg$parsetable_key();\r\n            if (s4 !== peg$FAILED) {\r\n              s5 = [];\r\n              s6 = peg$parseS();\r\n              while (s6 !== peg$FAILED) {\r\n                s5.push(s6);\r\n                s6 = peg$parseS();\r\n              }\r\n              if (s5 !== peg$FAILED) {\r\n                if (input.charCodeAt(peg$currPos) === 93) {\r\n                  s6 = peg$c9;\r\n                  peg$currPos++;\r\n                } else {\r\n                  s6 = peg$FAILED;\r\n                  if (peg$silentFails === 0) { peg$fail(peg$c10); }\r\n                }\r\n                if (s6 !== peg$FAILED) {\r\n                  if (input.charCodeAt(peg$currPos) === 93) {\r\n                    s7 = peg$c9;\r\n                    peg$currPos++;\r\n                  } else {\r\n                    s7 = peg$FAILED;\r\n                    if (peg$silentFails === 0) { peg$fail(peg$c10); }\r\n                  }\r\n                  if (s7 !== peg$FAILED) {\r\n                    peg$reportedPos = s0;\r\n                    s1 = peg$c12(s4);\r\n                    s0 = s1;\r\n                  } else {\r\n                    peg$currPos = s0;\r\n                    s0 = peg$c2;\r\n                  }\r\n                } else {\r\n                  peg$currPos = s0;\r\n                  s0 = peg$c2;\r\n                }\r\n              } else {\r\n                peg$currPos = s0;\r\n                s0 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsetable_key() {\r\n      var s0, s1, s2;\r\n\r\n      var key    = peg$currPos * 49 + 6,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = [];\r\n      s2 = peg$parsedot_ended_table_key_part();\r\n      if (s2 !== peg$FAILED) {\r\n        while (s2 !== peg$FAILED) {\r\n          s1.push(s2);\r\n          s2 = peg$parsedot_ended_table_key_part();\r\n        }\r\n      } else {\r\n        s1 = peg$c2;\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = peg$parsetable_key_part();\r\n        if (s2 !== peg$FAILED) {\r\n          peg$reportedPos = s0;\r\n          s1 = peg$c13(s1, s2);\r\n          s0 = s1;\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$currPos;\r\n        s1 = peg$parsetable_key_part();\r\n        if (s1 !== peg$FAILED) {\r\n          peg$reportedPos = s0;\r\n          s1 = peg$c14(s1);\r\n        }\r\n        s0 = s1;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsetable_key_part() {\r\n      var s0, s1, s2, s3, s4;\r\n\r\n      var key    = peg$currPos * 49 + 7,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = [];\r\n      s2 = peg$parseS();\r\n      while (s2 !== peg$FAILED) {\r\n        s1.push(s2);\r\n        s2 = peg$parseS();\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = peg$parsekey();\r\n        if (s2 !== peg$FAILED) {\r\n          s3 = [];\r\n          s4 = peg$parseS();\r\n          while (s4 !== peg$FAILED) {\r\n            s3.push(s4);\r\n            s4 = peg$parseS();\r\n          }\r\n          if (s3 !== peg$FAILED) {\r\n            peg$reportedPos = s0;\r\n            s1 = peg$c15(s2);\r\n            s0 = s1;\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$currPos;\r\n        s1 = [];\r\n        s2 = peg$parseS();\r\n        while (s2 !== peg$FAILED) {\r\n          s1.push(s2);\r\n          s2 = peg$parseS();\r\n        }\r\n        if (s1 !== peg$FAILED) {\r\n          s2 = peg$parsequoted_key();\r\n          if (s2 !== peg$FAILED) {\r\n            s3 = [];\r\n            s4 = peg$parseS();\r\n            while (s4 !== peg$FAILED) {\r\n              s3.push(s4);\r\n              s4 = peg$parseS();\r\n            }\r\n            if (s3 !== peg$FAILED) {\r\n              peg$reportedPos = s0;\r\n              s1 = peg$c15(s2);\r\n              s0 = s1;\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsedot_ended_table_key_part() {\r\n      var s0, s1, s2, s3, s4, s5, s6;\r\n\r\n      var key    = peg$currPos * 49 + 8,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = [];\r\n      s2 = peg$parseS();\r\n      while (s2 !== peg$FAILED) {\r\n        s1.push(s2);\r\n        s2 = peg$parseS();\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = peg$parsekey();\r\n        if (s2 !== peg$FAILED) {\r\n          s3 = [];\r\n          s4 = peg$parseS();\r\n          while (s4 !== peg$FAILED) {\r\n            s3.push(s4);\r\n            s4 = peg$parseS();\r\n          }\r\n          if (s3 !== peg$FAILED) {\r\n            if (input.charCodeAt(peg$currPos) === 46) {\r\n              s4 = peg$c16;\r\n              peg$currPos++;\r\n            } else {\r\n              s4 = peg$FAILED;\r\n              if (peg$silentFails === 0) { peg$fail(peg$c17); }\r\n            }\r\n            if (s4 !== peg$FAILED) {\r\n              s5 = [];\r\n              s6 = peg$parseS();\r\n              while (s6 !== peg$FAILED) {\r\n                s5.push(s6);\r\n                s6 = peg$parseS();\r\n              }\r\n              if (s5 !== peg$FAILED) {\r\n                peg$reportedPos = s0;\r\n                s1 = peg$c15(s2);\r\n                s0 = s1;\r\n              } else {\r\n                peg$currPos = s0;\r\n                s0 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$currPos;\r\n        s1 = [];\r\n        s2 = peg$parseS();\r\n        while (s2 !== peg$FAILED) {\r\n          s1.push(s2);\r\n          s2 = peg$parseS();\r\n        }\r\n        if (s1 !== peg$FAILED) {\r\n          s2 = peg$parsequoted_key();\r\n          if (s2 !== peg$FAILED) {\r\n            s3 = [];\r\n            s4 = peg$parseS();\r\n            while (s4 !== peg$FAILED) {\r\n              s3.push(s4);\r\n              s4 = peg$parseS();\r\n            }\r\n            if (s3 !== peg$FAILED) {\r\n              if (input.charCodeAt(peg$currPos) === 46) {\r\n                s4 = peg$c16;\r\n                peg$currPos++;\r\n              } else {\r\n                s4 = peg$FAILED;\r\n                if (peg$silentFails === 0) { peg$fail(peg$c17); }\r\n              }\r\n              if (s4 !== peg$FAILED) {\r\n                s5 = [];\r\n                s6 = peg$parseS();\r\n                while (s6 !== peg$FAILED) {\r\n                  s5.push(s6);\r\n                  s6 = peg$parseS();\r\n                }\r\n                if (s5 !== peg$FAILED) {\r\n                  peg$reportedPos = s0;\r\n                  s1 = peg$c15(s2);\r\n                  s0 = s1;\r\n                } else {\r\n                  peg$currPos = s0;\r\n                  s0 = peg$c2;\r\n                }\r\n              } else {\r\n                peg$currPos = s0;\r\n                s0 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseassignment() {\r\n      var s0, s1, s2, s3, s4, s5;\r\n\r\n      var key    = peg$currPos * 49 + 9,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = peg$parsekey();\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = [];\r\n        s3 = peg$parseS();\r\n        while (s3 !== peg$FAILED) {\r\n          s2.push(s3);\r\n          s3 = peg$parseS();\r\n        }\r\n        if (s2 !== peg$FAILED) {\r\n          if (input.charCodeAt(peg$currPos) === 61) {\r\n            s3 = peg$c18;\r\n            peg$currPos++;\r\n          } else {\r\n            s3 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$c19); }\r\n          }\r\n          if (s3 !== peg$FAILED) {\r\n            s4 = [];\r\n            s5 = peg$parseS();\r\n            while (s5 !== peg$FAILED) {\r\n              s4.push(s5);\r\n              s5 = peg$parseS();\r\n            }\r\n            if (s4 !== peg$FAILED) {\r\n              s5 = peg$parsevalue();\r\n              if (s5 !== peg$FAILED) {\r\n                peg$reportedPos = s0;\r\n                s1 = peg$c20(s1, s5);\r\n                s0 = s1;\r\n              } else {\r\n                peg$currPos = s0;\r\n                s0 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$currPos;\r\n        s1 = peg$parsequoted_key();\r\n        if (s1 !== peg$FAILED) {\r\n          s2 = [];\r\n          s3 = peg$parseS();\r\n          while (s3 !== peg$FAILED) {\r\n            s2.push(s3);\r\n            s3 = peg$parseS();\r\n          }\r\n          if (s2 !== peg$FAILED) {\r\n            if (input.charCodeAt(peg$currPos) === 61) {\r\n              s3 = peg$c18;\r\n              peg$currPos++;\r\n            } else {\r\n              s3 = peg$FAILED;\r\n              if (peg$silentFails === 0) { peg$fail(peg$c19); }\r\n            }\r\n            if (s3 !== peg$FAILED) {\r\n              s4 = [];\r\n              s5 = peg$parseS();\r\n              while (s5 !== peg$FAILED) {\r\n                s4.push(s5);\r\n                s5 = peg$parseS();\r\n              }\r\n              if (s4 !== peg$FAILED) {\r\n                s5 = peg$parsevalue();\r\n                if (s5 !== peg$FAILED) {\r\n                  peg$reportedPos = s0;\r\n                  s1 = peg$c20(s1, s5);\r\n                  s0 = s1;\r\n                } else {\r\n                  peg$currPos = s0;\r\n                  s0 = peg$c2;\r\n                }\r\n              } else {\r\n                peg$currPos = s0;\r\n                s0 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsekey() {\r\n      var s0, s1, s2;\r\n\r\n      var key    = peg$currPos * 49 + 10,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = [];\r\n      s2 = peg$parseASCII_BASIC();\r\n      if (s2 !== peg$FAILED) {\r\n        while (s2 !== peg$FAILED) {\r\n          s1.push(s2);\r\n          s2 = peg$parseASCII_BASIC();\r\n        }\r\n      } else {\r\n        s1 = peg$c2;\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        peg$reportedPos = s0;\r\n        s1 = peg$c21(s1);\r\n      }\r\n      s0 = s1;\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsequoted_key() {\r\n      var s0, s1;\r\n\r\n      var key    = peg$currPos * 49 + 11,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = peg$parsedouble_quoted_single_line_string();\r\n      if (s1 !== peg$FAILED) {\r\n        peg$reportedPos = s0;\r\n        s1 = peg$c22(s1);\r\n      }\r\n      s0 = s1;\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$currPos;\r\n        s1 = peg$parsesingle_quoted_single_line_string();\r\n        if (s1 !== peg$FAILED) {\r\n          peg$reportedPos = s0;\r\n          s1 = peg$c22(s1);\r\n        }\r\n        s0 = s1;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsevalue() {\r\n      var s0;\r\n\r\n      var key    = peg$currPos * 49 + 12,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$parsestring();\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$parsedatetime();\r\n        if (s0 === peg$FAILED) {\r\n          s0 = peg$parsefloat();\r\n          if (s0 === peg$FAILED) {\r\n            s0 = peg$parseinteger();\r\n            if (s0 === peg$FAILED) {\r\n              s0 = peg$parseboolean();\r\n              if (s0 === peg$FAILED) {\r\n                s0 = peg$parsearray();\r\n                if (s0 === peg$FAILED) {\r\n                  s0 = peg$parseinline_table();\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsestring() {\r\n      var s0;\r\n\r\n      var key    = peg$currPos * 49 + 13,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$parsedouble_quoted_multiline_string();\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$parsedouble_quoted_single_line_string();\r\n        if (s0 === peg$FAILED) {\r\n          s0 = peg$parsesingle_quoted_multiline_string();\r\n          if (s0 === peg$FAILED) {\r\n            s0 = peg$parsesingle_quoted_single_line_string();\r\n          }\r\n        }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsedouble_quoted_multiline_string() {\r\n      var s0, s1, s2, s3, s4;\r\n\r\n      var key    = peg$currPos * 49 + 14,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      if (input.substr(peg$currPos, 3) === peg$c23) {\r\n        s1 = peg$c23;\r\n        peg$currPos += 3;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c24); }\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = peg$parseNL();\r\n        if (s2 === peg$FAILED) {\r\n          s2 = peg$c25;\r\n        }\r\n        if (s2 !== peg$FAILED) {\r\n          s3 = [];\r\n          s4 = peg$parsemultiline_string_char();\r\n          while (s4 !== peg$FAILED) {\r\n            s3.push(s4);\r\n            s4 = peg$parsemultiline_string_char();\r\n          }\r\n          if (s3 !== peg$FAILED) {\r\n            if (input.substr(peg$currPos, 3) === peg$c23) {\r\n              s4 = peg$c23;\r\n              peg$currPos += 3;\r\n            } else {\r\n              s4 = peg$FAILED;\r\n              if (peg$silentFails === 0) { peg$fail(peg$c24); }\r\n            }\r\n            if (s4 !== peg$FAILED) {\r\n              peg$reportedPos = s0;\r\n              s1 = peg$c26(s3);\r\n              s0 = s1;\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsedouble_quoted_single_line_string() {\r\n      var s0, s1, s2, s3;\r\n\r\n      var key    = peg$currPos * 49 + 15,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      if (input.charCodeAt(peg$currPos) === 34) {\r\n        s1 = peg$c27;\r\n        peg$currPos++;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c28); }\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = [];\r\n        s3 = peg$parsestring_char();\r\n        while (s3 !== peg$FAILED) {\r\n          s2.push(s3);\r\n          s3 = peg$parsestring_char();\r\n        }\r\n        if (s2 !== peg$FAILED) {\r\n          if (input.charCodeAt(peg$currPos) === 34) {\r\n            s3 = peg$c27;\r\n            peg$currPos++;\r\n          } else {\r\n            s3 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$c28); }\r\n          }\r\n          if (s3 !== peg$FAILED) {\r\n            peg$reportedPos = s0;\r\n            s1 = peg$c26(s2);\r\n            s0 = s1;\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsesingle_quoted_multiline_string() {\r\n      var s0, s1, s2, s3, s4;\r\n\r\n      var key    = peg$currPos * 49 + 16,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      if (input.substr(peg$currPos, 3) === peg$c29) {\r\n        s1 = peg$c29;\r\n        peg$currPos += 3;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c30); }\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = peg$parseNL();\r\n        if (s2 === peg$FAILED) {\r\n          s2 = peg$c25;\r\n        }\r\n        if (s2 !== peg$FAILED) {\r\n          s3 = [];\r\n          s4 = peg$parsemultiline_literal_char();\r\n          while (s4 !== peg$FAILED) {\r\n            s3.push(s4);\r\n            s4 = peg$parsemultiline_literal_char();\r\n          }\r\n          if (s3 !== peg$FAILED) {\r\n            if (input.substr(peg$currPos, 3) === peg$c29) {\r\n              s4 = peg$c29;\r\n              peg$currPos += 3;\r\n            } else {\r\n              s4 = peg$FAILED;\r\n              if (peg$silentFails === 0) { peg$fail(peg$c30); }\r\n            }\r\n            if (s4 !== peg$FAILED) {\r\n              peg$reportedPos = s0;\r\n              s1 = peg$c26(s3);\r\n              s0 = s1;\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsesingle_quoted_single_line_string() {\r\n      var s0, s1, s2, s3;\r\n\r\n      var key    = peg$currPos * 49 + 17,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      if (input.charCodeAt(peg$currPos) === 39) {\r\n        s1 = peg$c31;\r\n        peg$currPos++;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = [];\r\n        s3 = peg$parseliteral_char();\r\n        while (s3 !== peg$FAILED) {\r\n          s2.push(s3);\r\n          s3 = peg$parseliteral_char();\r\n        }\r\n        if (s2 !== peg$FAILED) {\r\n          if (input.charCodeAt(peg$currPos) === 39) {\r\n            s3 = peg$c31;\r\n            peg$currPos++;\r\n          } else {\r\n            s3 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$c32); }\r\n          }\r\n          if (s3 !== peg$FAILED) {\r\n            peg$reportedPos = s0;\r\n            s1 = peg$c26(s2);\r\n            s0 = s1;\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsestring_char() {\r\n      var s0, s1, s2;\r\n\r\n      var key    = peg$currPos * 49 + 18,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$parseESCAPED();\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$currPos;\r\n        s1 = peg$currPos;\r\n        peg$silentFails++;\r\n        if (input.charCodeAt(peg$currPos) === 34) {\r\n          s2 = peg$c27;\r\n          peg$currPos++;\r\n        } else {\r\n          s2 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\r\n        }\r\n        peg$silentFails--;\r\n        if (s2 === peg$FAILED) {\r\n          s1 = peg$c5;\r\n        } else {\r\n          peg$currPos = s1;\r\n          s1 = peg$c2;\r\n        }\r\n        if (s1 !== peg$FAILED) {\r\n          if (input.length > peg$currPos) {\r\n            s2 = input.charAt(peg$currPos);\r\n            peg$currPos++;\r\n          } else {\r\n            s2 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$c6); }\r\n          }\r\n          if (s2 !== peg$FAILED) {\r\n            peg$reportedPos = s0;\r\n            s1 = peg$c33(s2);\r\n            s0 = s1;\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseliteral_char() {\r\n      var s0, s1, s2;\r\n\r\n      var key    = peg$currPos * 49 + 19,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = peg$currPos;\r\n      peg$silentFails++;\r\n      if (input.charCodeAt(peg$currPos) === 39) {\r\n        s2 = peg$c31;\r\n        peg$currPos++;\r\n      } else {\r\n        s2 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\r\n      }\r\n      peg$silentFails--;\r\n      if (s2 === peg$FAILED) {\r\n        s1 = peg$c5;\r\n      } else {\r\n        peg$currPos = s1;\r\n        s1 = peg$c2;\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        if (input.length > peg$currPos) {\r\n          s2 = input.charAt(peg$currPos);\r\n          peg$currPos++;\r\n        } else {\r\n          s2 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$c6); }\r\n        }\r\n        if (s2 !== peg$FAILED) {\r\n          peg$reportedPos = s0;\r\n          s1 = peg$c33(s2);\r\n          s0 = s1;\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsemultiline_string_char() {\r\n      var s0, s1, s2;\r\n\r\n      var key    = peg$currPos * 49 + 20,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$parseESCAPED();\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$parsemultiline_string_delim();\r\n        if (s0 === peg$FAILED) {\r\n          s0 = peg$currPos;\r\n          s1 = peg$currPos;\r\n          peg$silentFails++;\r\n          if (input.substr(peg$currPos, 3) === peg$c23) {\r\n            s2 = peg$c23;\r\n            peg$currPos += 3;\r\n          } else {\r\n            s2 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$c24); }\r\n          }\r\n          peg$silentFails--;\r\n          if (s2 === peg$FAILED) {\r\n            s1 = peg$c5;\r\n          } else {\r\n            peg$currPos = s1;\r\n            s1 = peg$c2;\r\n          }\r\n          if (s1 !== peg$FAILED) {\r\n            if (input.length > peg$currPos) {\r\n              s2 = input.charAt(peg$currPos);\r\n              peg$currPos++;\r\n            } else {\r\n              s2 = peg$FAILED;\r\n              if (peg$silentFails === 0) { peg$fail(peg$c6); }\r\n            }\r\n            if (s2 !== peg$FAILED) {\r\n              peg$reportedPos = s0;\r\n              s1 = peg$c34(s2);\r\n              s0 = s1;\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsemultiline_string_delim() {\r\n      var s0, s1, s2, s3, s4;\r\n\r\n      var key    = peg$currPos * 49 + 21,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      if (input.charCodeAt(peg$currPos) === 92) {\r\n        s1 = peg$c35;\r\n        peg$currPos++;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = peg$parseNL();\r\n        if (s2 !== peg$FAILED) {\r\n          s3 = [];\r\n          s4 = peg$parseNLS();\r\n          while (s4 !== peg$FAILED) {\r\n            s3.push(s4);\r\n            s4 = peg$parseNLS();\r\n          }\r\n          if (s3 !== peg$FAILED) {\r\n            peg$reportedPos = s0;\r\n            s1 = peg$c37();\r\n            s0 = s1;\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsemultiline_literal_char() {\r\n      var s0, s1, s2;\r\n\r\n      var key    = peg$currPos * 49 + 22,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = peg$currPos;\r\n      peg$silentFails++;\r\n      if (input.substr(peg$currPos, 3) === peg$c29) {\r\n        s2 = peg$c29;\r\n        peg$currPos += 3;\r\n      } else {\r\n        s2 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c30); }\r\n      }\r\n      peg$silentFails--;\r\n      if (s2 === peg$FAILED) {\r\n        s1 = peg$c5;\r\n      } else {\r\n        peg$currPos = s1;\r\n        s1 = peg$c2;\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        if (input.length > peg$currPos) {\r\n          s2 = input.charAt(peg$currPos);\r\n          peg$currPos++;\r\n        } else {\r\n          s2 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$c6); }\r\n        }\r\n        if (s2 !== peg$FAILED) {\r\n          peg$reportedPos = s0;\r\n          s1 = peg$c33(s2);\r\n          s0 = s1;\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsefloat() {\r\n      var s0, s1, s2, s3;\r\n\r\n      var key    = peg$currPos * 49 + 23,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = peg$parsefloat_text();\r\n      if (s1 === peg$FAILED) {\r\n        s1 = peg$parseinteger_text();\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        if (input.charCodeAt(peg$currPos) === 101) {\r\n          s2 = peg$c38;\r\n          peg$currPos++;\r\n        } else {\r\n          s2 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$c39); }\r\n        }\r\n        if (s2 === peg$FAILED) {\r\n          if (input.charCodeAt(peg$currPos) === 69) {\r\n            s2 = peg$c40;\r\n            peg$currPos++;\r\n          } else {\r\n            s2 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$c41); }\r\n          }\r\n        }\r\n        if (s2 !== peg$FAILED) {\r\n          s3 = peg$parseinteger_text();\r\n          if (s3 !== peg$FAILED) {\r\n            peg$reportedPos = s0;\r\n            s1 = peg$c42(s1, s3);\r\n            s0 = s1;\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$currPos;\r\n        s1 = peg$parsefloat_text();\r\n        if (s1 !== peg$FAILED) {\r\n          peg$reportedPos = s0;\r\n          s1 = peg$c43(s1);\r\n        }\r\n        s0 = s1;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsefloat_text() {\r\n      var s0, s1, s2, s3, s4, s5;\r\n\r\n      var key    = peg$currPos * 49 + 24,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      if (input.charCodeAt(peg$currPos) === 43) {\r\n        s1 = peg$c44;\r\n        peg$currPos++;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c45); }\r\n      }\r\n      if (s1 === peg$FAILED) {\r\n        s1 = peg$c25;\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = peg$currPos;\r\n        s3 = peg$parseDIGITS();\r\n        if (s3 !== peg$FAILED) {\r\n          if (input.charCodeAt(peg$currPos) === 46) {\r\n            s4 = peg$c16;\r\n            peg$currPos++;\r\n          } else {\r\n            s4 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$c17); }\r\n          }\r\n          if (s4 !== peg$FAILED) {\r\n            s5 = peg$parseDIGITS();\r\n            if (s5 !== peg$FAILED) {\r\n              s3 = [s3, s4, s5];\r\n              s2 = s3;\r\n            } else {\r\n              peg$currPos = s2;\r\n              s2 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s2;\r\n            s2 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s2;\r\n          s2 = peg$c2;\r\n        }\r\n        if (s2 !== peg$FAILED) {\r\n          peg$reportedPos = s0;\r\n          s1 = peg$c46(s2);\r\n          s0 = s1;\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$currPos;\r\n        if (input.charCodeAt(peg$currPos) === 45) {\r\n          s1 = peg$c47;\r\n          peg$currPos++;\r\n        } else {\r\n          s1 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$c48); }\r\n        }\r\n        if (s1 !== peg$FAILED) {\r\n          s2 = peg$currPos;\r\n          s3 = peg$parseDIGITS();\r\n          if (s3 !== peg$FAILED) {\r\n            if (input.charCodeAt(peg$currPos) === 46) {\r\n              s4 = peg$c16;\r\n              peg$currPos++;\r\n            } else {\r\n              s4 = peg$FAILED;\r\n              if (peg$silentFails === 0) { peg$fail(peg$c17); }\r\n            }\r\n            if (s4 !== peg$FAILED) {\r\n              s5 = peg$parseDIGITS();\r\n              if (s5 !== peg$FAILED) {\r\n                s3 = [s3, s4, s5];\r\n                s2 = s3;\r\n              } else {\r\n                peg$currPos = s2;\r\n                s2 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s2;\r\n              s2 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s2;\r\n            s2 = peg$c2;\r\n          }\r\n          if (s2 !== peg$FAILED) {\r\n            peg$reportedPos = s0;\r\n            s1 = peg$c49(s2);\r\n            s0 = s1;\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseinteger() {\r\n      var s0, s1;\r\n\r\n      var key    = peg$currPos * 49 + 25,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = peg$parseinteger_text();\r\n      if (s1 !== peg$FAILED) {\r\n        peg$reportedPos = s0;\r\n        s1 = peg$c50(s1);\r\n      }\r\n      s0 = s1;\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseinteger_text() {\r\n      var s0, s1, s2, s3, s4;\r\n\r\n      var key    = peg$currPos * 49 + 26,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      if (input.charCodeAt(peg$currPos) === 43) {\r\n        s1 = peg$c44;\r\n        peg$currPos++;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c45); }\r\n      }\r\n      if (s1 === peg$FAILED) {\r\n        s1 = peg$c25;\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = [];\r\n        s3 = peg$parseDIGIT_OR_UNDER();\r\n        if (s3 !== peg$FAILED) {\r\n          while (s3 !== peg$FAILED) {\r\n            s2.push(s3);\r\n            s3 = peg$parseDIGIT_OR_UNDER();\r\n          }\r\n        } else {\r\n          s2 = peg$c2;\r\n        }\r\n        if (s2 !== peg$FAILED) {\r\n          s3 = peg$currPos;\r\n          peg$silentFails++;\r\n          if (input.charCodeAt(peg$currPos) === 46) {\r\n            s4 = peg$c16;\r\n            peg$currPos++;\r\n          } else {\r\n            s4 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$c17); }\r\n          }\r\n          peg$silentFails--;\r\n          if (s4 === peg$FAILED) {\r\n            s3 = peg$c5;\r\n          } else {\r\n            peg$currPos = s3;\r\n            s3 = peg$c2;\r\n          }\r\n          if (s3 !== peg$FAILED) {\r\n            peg$reportedPos = s0;\r\n            s1 = peg$c46(s2);\r\n            s0 = s1;\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$currPos;\r\n        if (input.charCodeAt(peg$currPos) === 45) {\r\n          s1 = peg$c47;\r\n          peg$currPos++;\r\n        } else {\r\n          s1 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$c48); }\r\n        }\r\n        if (s1 !== peg$FAILED) {\r\n          s2 = [];\r\n          s3 = peg$parseDIGIT_OR_UNDER();\r\n          if (s3 !== peg$FAILED) {\r\n            while (s3 !== peg$FAILED) {\r\n              s2.push(s3);\r\n              s3 = peg$parseDIGIT_OR_UNDER();\r\n            }\r\n          } else {\r\n            s2 = peg$c2;\r\n          }\r\n          if (s2 !== peg$FAILED) {\r\n            s3 = peg$currPos;\r\n            peg$silentFails++;\r\n            if (input.charCodeAt(peg$currPos) === 46) {\r\n              s4 = peg$c16;\r\n              peg$currPos++;\r\n            } else {\r\n              s4 = peg$FAILED;\r\n              if (peg$silentFails === 0) { peg$fail(peg$c17); }\r\n            }\r\n            peg$silentFails--;\r\n            if (s4 === peg$FAILED) {\r\n              s3 = peg$c5;\r\n            } else {\r\n              peg$currPos = s3;\r\n              s3 = peg$c2;\r\n            }\r\n            if (s3 !== peg$FAILED) {\r\n              peg$reportedPos = s0;\r\n              s1 = peg$c49(s2);\r\n              s0 = s1;\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseboolean() {\r\n      var s0, s1;\r\n\r\n      var key    = peg$currPos * 49 + 27,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      if (input.substr(peg$currPos, 4) === peg$c51) {\r\n        s1 = peg$c51;\r\n        peg$currPos += 4;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c52); }\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        peg$reportedPos = s0;\r\n        s1 = peg$c53();\r\n      }\r\n      s0 = s1;\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$currPos;\r\n        if (input.substr(peg$currPos, 5) === peg$c54) {\r\n          s1 = peg$c54;\r\n          peg$currPos += 5;\r\n        } else {\r\n          s1 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$c55); }\r\n        }\r\n        if (s1 !== peg$FAILED) {\r\n          peg$reportedPos = s0;\r\n          s1 = peg$c56();\r\n        }\r\n        s0 = s1;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsearray() {\r\n      var s0, s1, s2, s3, s4;\r\n\r\n      var key    = peg$currPos * 49 + 28,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      if (input.charCodeAt(peg$currPos) === 91) {\r\n        s1 = peg$c7;\r\n        peg$currPos++;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c8); }\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = [];\r\n        s3 = peg$parsearray_sep();\r\n        while (s3 !== peg$FAILED) {\r\n          s2.push(s3);\r\n          s3 = peg$parsearray_sep();\r\n        }\r\n        if (s2 !== peg$FAILED) {\r\n          if (input.charCodeAt(peg$currPos) === 93) {\r\n            s3 = peg$c9;\r\n            peg$currPos++;\r\n          } else {\r\n            s3 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$c10); }\r\n          }\r\n          if (s3 !== peg$FAILED) {\r\n            peg$reportedPos = s0;\r\n            s1 = peg$c57();\r\n            s0 = s1;\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$currPos;\r\n        if (input.charCodeAt(peg$currPos) === 91) {\r\n          s1 = peg$c7;\r\n          peg$currPos++;\r\n        } else {\r\n          s1 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\r\n        }\r\n        if (s1 !== peg$FAILED) {\r\n          s2 = peg$parsearray_value();\r\n          if (s2 === peg$FAILED) {\r\n            s2 = peg$c25;\r\n          }\r\n          if (s2 !== peg$FAILED) {\r\n            if (input.charCodeAt(peg$currPos) === 93) {\r\n              s3 = peg$c9;\r\n              peg$currPos++;\r\n            } else {\r\n              s3 = peg$FAILED;\r\n              if (peg$silentFails === 0) { peg$fail(peg$c10); }\r\n            }\r\n            if (s3 !== peg$FAILED) {\r\n              peg$reportedPos = s0;\r\n              s1 = peg$c58(s2);\r\n              s0 = s1;\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n        if (s0 === peg$FAILED) {\r\n          s0 = peg$currPos;\r\n          if (input.charCodeAt(peg$currPos) === 91) {\r\n            s1 = peg$c7;\r\n            peg$currPos++;\r\n          } else {\r\n            s1 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$c8); }\r\n          }\r\n          if (s1 !== peg$FAILED) {\r\n            s2 = [];\r\n            s3 = peg$parsearray_value_list();\r\n            if (s3 !== peg$FAILED) {\r\n              while (s3 !== peg$FAILED) {\r\n                s2.push(s3);\r\n                s3 = peg$parsearray_value_list();\r\n              }\r\n            } else {\r\n              s2 = peg$c2;\r\n            }\r\n            if (s2 !== peg$FAILED) {\r\n              if (input.charCodeAt(peg$currPos) === 93) {\r\n                s3 = peg$c9;\r\n                peg$currPos++;\r\n              } else {\r\n                s3 = peg$FAILED;\r\n                if (peg$silentFails === 0) { peg$fail(peg$c10); }\r\n              }\r\n              if (s3 !== peg$FAILED) {\r\n                peg$reportedPos = s0;\r\n                s1 = peg$c59(s2);\r\n                s0 = s1;\r\n              } else {\r\n                peg$currPos = s0;\r\n                s0 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n          if (s0 === peg$FAILED) {\r\n            s0 = peg$currPos;\r\n            if (input.charCodeAt(peg$currPos) === 91) {\r\n              s1 = peg$c7;\r\n              peg$currPos++;\r\n            } else {\r\n              s1 = peg$FAILED;\r\n              if (peg$silentFails === 0) { peg$fail(peg$c8); }\r\n            }\r\n            if (s1 !== peg$FAILED) {\r\n              s2 = [];\r\n              s3 = peg$parsearray_value_list();\r\n              if (s3 !== peg$FAILED) {\r\n                while (s3 !== peg$FAILED) {\r\n                  s2.push(s3);\r\n                  s3 = peg$parsearray_value_list();\r\n                }\r\n              } else {\r\n                s2 = peg$c2;\r\n              }\r\n              if (s2 !== peg$FAILED) {\r\n                s3 = peg$parsearray_value();\r\n                if (s3 !== peg$FAILED) {\r\n                  if (input.charCodeAt(peg$currPos) === 93) {\r\n                    s4 = peg$c9;\r\n                    peg$currPos++;\r\n                  } else {\r\n                    s4 = peg$FAILED;\r\n                    if (peg$silentFails === 0) { peg$fail(peg$c10); }\r\n                  }\r\n                  if (s4 !== peg$FAILED) {\r\n                    peg$reportedPos = s0;\r\n                    s1 = peg$c60(s2, s3);\r\n                    s0 = s1;\r\n                  } else {\r\n                    peg$currPos = s0;\r\n                    s0 = peg$c2;\r\n                  }\r\n                } else {\r\n                  peg$currPos = s0;\r\n                  s0 = peg$c2;\r\n                }\r\n              } else {\r\n                peg$currPos = s0;\r\n                s0 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsearray_value() {\r\n      var s0, s1, s2, s3, s4;\r\n\r\n      var key    = peg$currPos * 49 + 29,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = [];\r\n      s2 = peg$parsearray_sep();\r\n      while (s2 !== peg$FAILED) {\r\n        s1.push(s2);\r\n        s2 = peg$parsearray_sep();\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = peg$parsevalue();\r\n        if (s2 !== peg$FAILED) {\r\n          s3 = [];\r\n          s4 = peg$parsearray_sep();\r\n          while (s4 !== peg$FAILED) {\r\n            s3.push(s4);\r\n            s4 = peg$parsearray_sep();\r\n          }\r\n          if (s3 !== peg$FAILED) {\r\n            peg$reportedPos = s0;\r\n            s1 = peg$c61(s2);\r\n            s0 = s1;\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsearray_value_list() {\r\n      var s0, s1, s2, s3, s4, s5, s6;\r\n\r\n      var key    = peg$currPos * 49 + 30,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = [];\r\n      s2 = peg$parsearray_sep();\r\n      while (s2 !== peg$FAILED) {\r\n        s1.push(s2);\r\n        s2 = peg$parsearray_sep();\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = peg$parsevalue();\r\n        if (s2 !== peg$FAILED) {\r\n          s3 = [];\r\n          s4 = peg$parsearray_sep();\r\n          while (s4 !== peg$FAILED) {\r\n            s3.push(s4);\r\n            s4 = peg$parsearray_sep();\r\n          }\r\n          if (s3 !== peg$FAILED) {\r\n            if (input.charCodeAt(peg$currPos) === 44) {\r\n              s4 = peg$c62;\r\n              peg$currPos++;\r\n            } else {\r\n              s4 = peg$FAILED;\r\n              if (peg$silentFails === 0) { peg$fail(peg$c63); }\r\n            }\r\n            if (s4 !== peg$FAILED) {\r\n              s5 = [];\r\n              s6 = peg$parsearray_sep();\r\n              while (s6 !== peg$FAILED) {\r\n                s5.push(s6);\r\n                s6 = peg$parsearray_sep();\r\n              }\r\n              if (s5 !== peg$FAILED) {\r\n                peg$reportedPos = s0;\r\n                s1 = peg$c61(s2);\r\n                s0 = s1;\r\n              } else {\r\n                peg$currPos = s0;\r\n                s0 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsearray_sep() {\r\n      var s0;\r\n\r\n      var key    = peg$currPos * 49 + 31,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$parseS();\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$parseNL();\r\n        if (s0 === peg$FAILED) {\r\n          s0 = peg$parsecomment();\r\n        }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseinline_table() {\r\n      var s0, s1, s2, s3, s4, s5;\r\n\r\n      var key    = peg$currPos * 49 + 32,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      if (input.charCodeAt(peg$currPos) === 123) {\r\n        s1 = peg$c64;\r\n        peg$currPos++;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c65); }\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = [];\r\n        s3 = peg$parseS();\r\n        while (s3 !== peg$FAILED) {\r\n          s2.push(s3);\r\n          s3 = peg$parseS();\r\n        }\r\n        if (s2 !== peg$FAILED) {\r\n          s3 = [];\r\n          s4 = peg$parseinline_table_assignment();\r\n          while (s4 !== peg$FAILED) {\r\n            s3.push(s4);\r\n            s4 = peg$parseinline_table_assignment();\r\n          }\r\n          if (s3 !== peg$FAILED) {\r\n            s4 = [];\r\n            s5 = peg$parseS();\r\n            while (s5 !== peg$FAILED) {\r\n              s4.push(s5);\r\n              s5 = peg$parseS();\r\n            }\r\n            if (s4 !== peg$FAILED) {\r\n              if (input.charCodeAt(peg$currPos) === 125) {\r\n                s5 = peg$c66;\r\n                peg$currPos++;\r\n              } else {\r\n                s5 = peg$FAILED;\r\n                if (peg$silentFails === 0) { peg$fail(peg$c67); }\r\n              }\r\n              if (s5 !== peg$FAILED) {\r\n                peg$reportedPos = s0;\r\n                s1 = peg$c68(s3);\r\n                s0 = s1;\r\n              } else {\r\n                peg$currPos = s0;\r\n                s0 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseinline_table_assignment() {\r\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\r\n\r\n      var key    = peg$currPos * 49 + 33,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = [];\r\n      s2 = peg$parseS();\r\n      while (s2 !== peg$FAILED) {\r\n        s1.push(s2);\r\n        s2 = peg$parseS();\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = peg$parsekey();\r\n        if (s2 !== peg$FAILED) {\r\n          s3 = [];\r\n          s4 = peg$parseS();\r\n          while (s4 !== peg$FAILED) {\r\n            s3.push(s4);\r\n            s4 = peg$parseS();\r\n          }\r\n          if (s3 !== peg$FAILED) {\r\n            if (input.charCodeAt(peg$currPos) === 61) {\r\n              s4 = peg$c18;\r\n              peg$currPos++;\r\n            } else {\r\n              s4 = peg$FAILED;\r\n              if (peg$silentFails === 0) { peg$fail(peg$c19); }\r\n            }\r\n            if (s4 !== peg$FAILED) {\r\n              s5 = [];\r\n              s6 = peg$parseS();\r\n              while (s6 !== peg$FAILED) {\r\n                s5.push(s6);\r\n                s6 = peg$parseS();\r\n              }\r\n              if (s5 !== peg$FAILED) {\r\n                s6 = peg$parsevalue();\r\n                if (s6 !== peg$FAILED) {\r\n                  s7 = [];\r\n                  s8 = peg$parseS();\r\n                  while (s8 !== peg$FAILED) {\r\n                    s7.push(s8);\r\n                    s8 = peg$parseS();\r\n                  }\r\n                  if (s7 !== peg$FAILED) {\r\n                    if (input.charCodeAt(peg$currPos) === 44) {\r\n                      s8 = peg$c62;\r\n                      peg$currPos++;\r\n                    } else {\r\n                      s8 = peg$FAILED;\r\n                      if (peg$silentFails === 0) { peg$fail(peg$c63); }\r\n                    }\r\n                    if (s8 !== peg$FAILED) {\r\n                      s9 = [];\r\n                      s10 = peg$parseS();\r\n                      while (s10 !== peg$FAILED) {\r\n                        s9.push(s10);\r\n                        s10 = peg$parseS();\r\n                      }\r\n                      if (s9 !== peg$FAILED) {\r\n                        peg$reportedPos = s0;\r\n                        s1 = peg$c69(s2, s6);\r\n                        s0 = s1;\r\n                      } else {\r\n                        peg$currPos = s0;\r\n                        s0 = peg$c2;\r\n                      }\r\n                    } else {\r\n                      peg$currPos = s0;\r\n                      s0 = peg$c2;\r\n                    }\r\n                  } else {\r\n                    peg$currPos = s0;\r\n                    s0 = peg$c2;\r\n                  }\r\n                } else {\r\n                  peg$currPos = s0;\r\n                  s0 = peg$c2;\r\n                }\r\n              } else {\r\n                peg$currPos = s0;\r\n                s0 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$currPos;\r\n        s1 = [];\r\n        s2 = peg$parseS();\r\n        while (s2 !== peg$FAILED) {\r\n          s1.push(s2);\r\n          s2 = peg$parseS();\r\n        }\r\n        if (s1 !== peg$FAILED) {\r\n          s2 = peg$parsekey();\r\n          if (s2 !== peg$FAILED) {\r\n            s3 = [];\r\n            s4 = peg$parseS();\r\n            while (s4 !== peg$FAILED) {\r\n              s3.push(s4);\r\n              s4 = peg$parseS();\r\n            }\r\n            if (s3 !== peg$FAILED) {\r\n              if (input.charCodeAt(peg$currPos) === 61) {\r\n                s4 = peg$c18;\r\n                peg$currPos++;\r\n              } else {\r\n                s4 = peg$FAILED;\r\n                if (peg$silentFails === 0) { peg$fail(peg$c19); }\r\n              }\r\n              if (s4 !== peg$FAILED) {\r\n                s5 = [];\r\n                s6 = peg$parseS();\r\n                while (s6 !== peg$FAILED) {\r\n                  s5.push(s6);\r\n                  s6 = peg$parseS();\r\n                }\r\n                if (s5 !== peg$FAILED) {\r\n                  s6 = peg$parsevalue();\r\n                  if (s6 !== peg$FAILED) {\r\n                    peg$reportedPos = s0;\r\n                    s1 = peg$c69(s2, s6);\r\n                    s0 = s1;\r\n                  } else {\r\n                    peg$currPos = s0;\r\n                    s0 = peg$c2;\r\n                  }\r\n                } else {\r\n                  peg$currPos = s0;\r\n                  s0 = peg$c2;\r\n                }\r\n              } else {\r\n                peg$currPos = s0;\r\n                s0 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsesecfragment() {\r\n      var s0, s1, s2;\r\n\r\n      var key    = peg$currPos * 49 + 34,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      if (input.charCodeAt(peg$currPos) === 46) {\r\n        s1 = peg$c16;\r\n        peg$currPos++;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c17); }\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = peg$parseDIGITS();\r\n        if (s2 !== peg$FAILED) {\r\n          peg$reportedPos = s0;\r\n          s1 = peg$c70(s2);\r\n          s0 = s1;\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsedate() {\r\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\r\n\r\n      var key    = peg$currPos * 49 + 35,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = peg$currPos;\r\n      s2 = peg$parseDIGIT_OR_UNDER();\r\n      if (s2 !== peg$FAILED) {\r\n        s3 = peg$parseDIGIT_OR_UNDER();\r\n        if (s3 !== peg$FAILED) {\r\n          s4 = peg$parseDIGIT_OR_UNDER();\r\n          if (s4 !== peg$FAILED) {\r\n            s5 = peg$parseDIGIT_OR_UNDER();\r\n            if (s5 !== peg$FAILED) {\r\n              if (input.charCodeAt(peg$currPos) === 45) {\r\n                s6 = peg$c47;\r\n                peg$currPos++;\r\n              } else {\r\n                s6 = peg$FAILED;\r\n                if (peg$silentFails === 0) { peg$fail(peg$c48); }\r\n              }\r\n              if (s6 !== peg$FAILED) {\r\n                s7 = peg$parseDIGIT_OR_UNDER();\r\n                if (s7 !== peg$FAILED) {\r\n                  s8 = peg$parseDIGIT_OR_UNDER();\r\n                  if (s8 !== peg$FAILED) {\r\n                    if (input.charCodeAt(peg$currPos) === 45) {\r\n                      s9 = peg$c47;\r\n                      peg$currPos++;\r\n                    } else {\r\n                      s9 = peg$FAILED;\r\n                      if (peg$silentFails === 0) { peg$fail(peg$c48); }\r\n                    }\r\n                    if (s9 !== peg$FAILED) {\r\n                      s10 = peg$parseDIGIT_OR_UNDER();\r\n                      if (s10 !== peg$FAILED) {\r\n                        s11 = peg$parseDIGIT_OR_UNDER();\r\n                        if (s11 !== peg$FAILED) {\r\n                          s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11];\r\n                          s1 = s2;\r\n                        } else {\r\n                          peg$currPos = s1;\r\n                          s1 = peg$c2;\r\n                        }\r\n                      } else {\r\n                        peg$currPos = s1;\r\n                        s1 = peg$c2;\r\n                      }\r\n                    } else {\r\n                      peg$currPos = s1;\r\n                      s1 = peg$c2;\r\n                    }\r\n                  } else {\r\n                    peg$currPos = s1;\r\n                    s1 = peg$c2;\r\n                  }\r\n                } else {\r\n                  peg$currPos = s1;\r\n                  s1 = peg$c2;\r\n                }\r\n              } else {\r\n                peg$currPos = s1;\r\n                s1 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s1;\r\n              s1 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s1;\r\n            s1 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s1;\r\n          s1 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s1;\r\n        s1 = peg$c2;\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        peg$reportedPos = s0;\r\n        s1 = peg$c71(s1);\r\n      }\r\n      s0 = s1;\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsetime() {\r\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\r\n\r\n      var key    = peg$currPos * 49 + 36,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = peg$currPos;\r\n      s2 = peg$parseDIGIT_OR_UNDER();\r\n      if (s2 !== peg$FAILED) {\r\n        s3 = peg$parseDIGIT_OR_UNDER();\r\n        if (s3 !== peg$FAILED) {\r\n          if (input.charCodeAt(peg$currPos) === 58) {\r\n            s4 = peg$c72;\r\n            peg$currPos++;\r\n          } else {\r\n            s4 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$c73); }\r\n          }\r\n          if (s4 !== peg$FAILED) {\r\n            s5 = peg$parseDIGIT_OR_UNDER();\r\n            if (s5 !== peg$FAILED) {\r\n              s6 = peg$parseDIGIT_OR_UNDER();\r\n              if (s6 !== peg$FAILED) {\r\n                if (input.charCodeAt(peg$currPos) === 58) {\r\n                  s7 = peg$c72;\r\n                  peg$currPos++;\r\n                } else {\r\n                  s7 = peg$FAILED;\r\n                  if (peg$silentFails === 0) { peg$fail(peg$c73); }\r\n                }\r\n                if (s7 !== peg$FAILED) {\r\n                  s8 = peg$parseDIGIT_OR_UNDER();\r\n                  if (s8 !== peg$FAILED) {\r\n                    s9 = peg$parseDIGIT_OR_UNDER();\r\n                    if (s9 !== peg$FAILED) {\r\n                      s10 = peg$parsesecfragment();\r\n                      if (s10 === peg$FAILED) {\r\n                        s10 = peg$c25;\r\n                      }\r\n                      if (s10 !== peg$FAILED) {\r\n                        s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10];\r\n                        s1 = s2;\r\n                      } else {\r\n                        peg$currPos = s1;\r\n                        s1 = peg$c2;\r\n                      }\r\n                    } else {\r\n                      peg$currPos = s1;\r\n                      s1 = peg$c2;\r\n                    }\r\n                  } else {\r\n                    peg$currPos = s1;\r\n                    s1 = peg$c2;\r\n                  }\r\n                } else {\r\n                  peg$currPos = s1;\r\n                  s1 = peg$c2;\r\n                }\r\n              } else {\r\n                peg$currPos = s1;\r\n                s1 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s1;\r\n              s1 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s1;\r\n            s1 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s1;\r\n          s1 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s1;\r\n        s1 = peg$c2;\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        peg$reportedPos = s0;\r\n        s1 = peg$c74(s1);\r\n      }\r\n      s0 = s1;\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsetime_with_offset() {\r\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16;\r\n\r\n      var key    = peg$currPos * 49 + 37,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = peg$currPos;\r\n      s2 = peg$parseDIGIT_OR_UNDER();\r\n      if (s2 !== peg$FAILED) {\r\n        s3 = peg$parseDIGIT_OR_UNDER();\r\n        if (s3 !== peg$FAILED) {\r\n          if (input.charCodeAt(peg$currPos) === 58) {\r\n            s4 = peg$c72;\r\n            peg$currPos++;\r\n          } else {\r\n            s4 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$c73); }\r\n          }\r\n          if (s4 !== peg$FAILED) {\r\n            s5 = peg$parseDIGIT_OR_UNDER();\r\n            if (s5 !== peg$FAILED) {\r\n              s6 = peg$parseDIGIT_OR_UNDER();\r\n              if (s6 !== peg$FAILED) {\r\n                if (input.charCodeAt(peg$currPos) === 58) {\r\n                  s7 = peg$c72;\r\n                  peg$currPos++;\r\n                } else {\r\n                  s7 = peg$FAILED;\r\n                  if (peg$silentFails === 0) { peg$fail(peg$c73); }\r\n                }\r\n                if (s7 !== peg$FAILED) {\r\n                  s8 = peg$parseDIGIT_OR_UNDER();\r\n                  if (s8 !== peg$FAILED) {\r\n                    s9 = peg$parseDIGIT_OR_UNDER();\r\n                    if (s9 !== peg$FAILED) {\r\n                      s10 = peg$parsesecfragment();\r\n                      if (s10 === peg$FAILED) {\r\n                        s10 = peg$c25;\r\n                      }\r\n                      if (s10 !== peg$FAILED) {\r\n                        if (input.charCodeAt(peg$currPos) === 45) {\r\n                          s11 = peg$c47;\r\n                          peg$currPos++;\r\n                        } else {\r\n                          s11 = peg$FAILED;\r\n                          if (peg$silentFails === 0) { peg$fail(peg$c48); }\r\n                        }\r\n                        if (s11 === peg$FAILED) {\r\n                          if (input.charCodeAt(peg$currPos) === 43) {\r\n                            s11 = peg$c44;\r\n                            peg$currPos++;\r\n                          } else {\r\n                            s11 = peg$FAILED;\r\n                            if (peg$silentFails === 0) { peg$fail(peg$c45); }\r\n                          }\r\n                        }\r\n                        if (s11 !== peg$FAILED) {\r\n                          s12 = peg$parseDIGIT_OR_UNDER();\r\n                          if (s12 !== peg$FAILED) {\r\n                            s13 = peg$parseDIGIT_OR_UNDER();\r\n                            if (s13 !== peg$FAILED) {\r\n                              if (input.charCodeAt(peg$currPos) === 58) {\r\n                                s14 = peg$c72;\r\n                                peg$currPos++;\r\n                              } else {\r\n                                s14 = peg$FAILED;\r\n                                if (peg$silentFails === 0) { peg$fail(peg$c73); }\r\n                              }\r\n                              if (s14 !== peg$FAILED) {\r\n                                s15 = peg$parseDIGIT_OR_UNDER();\r\n                                if (s15 !== peg$FAILED) {\r\n                                  s16 = peg$parseDIGIT_OR_UNDER();\r\n                                  if (s16 !== peg$FAILED) {\r\n                                    s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16];\r\n                                    s1 = s2;\r\n                                  } else {\r\n                                    peg$currPos = s1;\r\n                                    s1 = peg$c2;\r\n                                  }\r\n                                } else {\r\n                                  peg$currPos = s1;\r\n                                  s1 = peg$c2;\r\n                                }\r\n                              } else {\r\n                                peg$currPos = s1;\r\n                                s1 = peg$c2;\r\n                              }\r\n                            } else {\r\n                              peg$currPos = s1;\r\n                              s1 = peg$c2;\r\n                            }\r\n                          } else {\r\n                            peg$currPos = s1;\r\n                            s1 = peg$c2;\r\n                          }\r\n                        } else {\r\n                          peg$currPos = s1;\r\n                          s1 = peg$c2;\r\n                        }\r\n                      } else {\r\n                        peg$currPos = s1;\r\n                        s1 = peg$c2;\r\n                      }\r\n                    } else {\r\n                      peg$currPos = s1;\r\n                      s1 = peg$c2;\r\n                    }\r\n                  } else {\r\n                    peg$currPos = s1;\r\n                    s1 = peg$c2;\r\n                  }\r\n                } else {\r\n                  peg$currPos = s1;\r\n                  s1 = peg$c2;\r\n                }\r\n              } else {\r\n                peg$currPos = s1;\r\n                s1 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s1;\r\n              s1 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s1;\r\n            s1 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s1;\r\n          s1 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s1;\r\n        s1 = peg$c2;\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        peg$reportedPos = s0;\r\n        s1 = peg$c74(s1);\r\n      }\r\n      s0 = s1;\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parsedatetime() {\r\n      var s0, s1, s2, s3, s4;\r\n\r\n      var key    = peg$currPos * 49 + 38,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = peg$parsedate();\r\n      if (s1 !== peg$FAILED) {\r\n        if (input.charCodeAt(peg$currPos) === 84) {\r\n          s2 = peg$c75;\r\n          peg$currPos++;\r\n        } else {\r\n          s2 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$c76); }\r\n        }\r\n        if (s2 !== peg$FAILED) {\r\n          s3 = peg$parsetime();\r\n          if (s3 !== peg$FAILED) {\r\n            if (input.charCodeAt(peg$currPos) === 90) {\r\n              s4 = peg$c77;\r\n              peg$currPos++;\r\n            } else {\r\n              s4 = peg$FAILED;\r\n              if (peg$silentFails === 0) { peg$fail(peg$c78); }\r\n            }\r\n            if (s4 !== peg$FAILED) {\r\n              peg$reportedPos = s0;\r\n              s1 = peg$c79(s1, s3);\r\n              s0 = s1;\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$currPos;\r\n        s1 = peg$parsedate();\r\n        if (s1 !== peg$FAILED) {\r\n          if (input.charCodeAt(peg$currPos) === 84) {\r\n            s2 = peg$c75;\r\n            peg$currPos++;\r\n          } else {\r\n            s2 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$c76); }\r\n          }\r\n          if (s2 !== peg$FAILED) {\r\n            s3 = peg$parsetime_with_offset();\r\n            if (s3 !== peg$FAILED) {\r\n              peg$reportedPos = s0;\r\n              s1 = peg$c80(s1, s3);\r\n              s0 = s1;\r\n            } else {\r\n              peg$currPos = s0;\r\n              s0 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseS() {\r\n      var s0;\r\n\r\n      var key    = peg$currPos * 49 + 39,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      if (peg$c81.test(input.charAt(peg$currPos))) {\r\n        s0 = input.charAt(peg$currPos);\r\n        peg$currPos++;\r\n      } else {\r\n        s0 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c82); }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseNL() {\r\n      var s0, s1, s2;\r\n\r\n      var key    = peg$currPos * 49 + 40,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      if (input.charCodeAt(peg$currPos) === 10) {\r\n        s0 = peg$c83;\r\n        peg$currPos++;\r\n      } else {\r\n        s0 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c84); }\r\n      }\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$currPos;\r\n        if (input.charCodeAt(peg$currPos) === 13) {\r\n          s1 = peg$c85;\r\n          peg$currPos++;\r\n        } else {\r\n          s1 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$c86); }\r\n        }\r\n        if (s1 !== peg$FAILED) {\r\n          if (input.charCodeAt(peg$currPos) === 10) {\r\n            s2 = peg$c83;\r\n            peg$currPos++;\r\n          } else {\r\n            s2 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$c84); }\r\n          }\r\n          if (s2 !== peg$FAILED) {\r\n            s1 = [s1, s2];\r\n            s0 = s1;\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseNLS() {\r\n      var s0;\r\n\r\n      var key    = peg$currPos * 49 + 41,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$parseNL();\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$parseS();\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseEOF() {\r\n      var s0, s1;\r\n\r\n      var key    = peg$currPos * 49 + 42,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      peg$silentFails++;\r\n      if (input.length > peg$currPos) {\r\n        s1 = input.charAt(peg$currPos);\r\n        peg$currPos++;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c6); }\r\n      }\r\n      peg$silentFails--;\r\n      if (s1 === peg$FAILED) {\r\n        s0 = peg$c5;\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseHEX() {\r\n      var s0;\r\n\r\n      var key    = peg$currPos * 49 + 43,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      if (peg$c87.test(input.charAt(peg$currPos))) {\r\n        s0 = input.charAt(peg$currPos);\r\n        peg$currPos++;\r\n      } else {\r\n        s0 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c88); }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseDIGIT_OR_UNDER() {\r\n      var s0, s1;\r\n\r\n      var key    = peg$currPos * 49 + 44,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      if (peg$c89.test(input.charAt(peg$currPos))) {\r\n        s0 = input.charAt(peg$currPos);\r\n        peg$currPos++;\r\n      } else {\r\n        s0 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c90); }\r\n      }\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$currPos;\r\n        if (input.charCodeAt(peg$currPos) === 95) {\r\n          s1 = peg$c91;\r\n          peg$currPos++;\r\n        } else {\r\n          s1 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$c92); }\r\n        }\r\n        if (s1 !== peg$FAILED) {\r\n          peg$reportedPos = s0;\r\n          s1 = peg$c93();\r\n        }\r\n        s0 = s1;\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseASCII_BASIC() {\r\n      var s0;\r\n\r\n      var key    = peg$currPos * 49 + 45,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      if (peg$c94.test(input.charAt(peg$currPos))) {\r\n        s0 = input.charAt(peg$currPos);\r\n        peg$currPos++;\r\n      } else {\r\n        s0 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c95); }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseDIGITS() {\r\n      var s0, s1, s2;\r\n\r\n      var key    = peg$currPos * 49 + 46,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      s1 = [];\r\n      s2 = peg$parseDIGIT_OR_UNDER();\r\n      if (s2 !== peg$FAILED) {\r\n        while (s2 !== peg$FAILED) {\r\n          s1.push(s2);\r\n          s2 = peg$parseDIGIT_OR_UNDER();\r\n        }\r\n      } else {\r\n        s1 = peg$c2;\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        peg$reportedPos = s0;\r\n        s1 = peg$c96(s1);\r\n      }\r\n      s0 = s1;\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseESCAPED() {\r\n      var s0, s1;\r\n\r\n      var key    = peg$currPos * 49 + 47,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      if (input.substr(peg$currPos, 2) === peg$c97) {\r\n        s1 = peg$c97;\r\n        peg$currPos += 2;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c98); }\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        peg$reportedPos = s0;\r\n        s1 = peg$c99();\r\n      }\r\n      s0 = s1;\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$currPos;\r\n        if (input.substr(peg$currPos, 2) === peg$c100) {\r\n          s1 = peg$c100;\r\n          peg$currPos += 2;\r\n        } else {\r\n          s1 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$c101); }\r\n        }\r\n        if (s1 !== peg$FAILED) {\r\n          peg$reportedPos = s0;\r\n          s1 = peg$c102();\r\n        }\r\n        s0 = s1;\r\n        if (s0 === peg$FAILED) {\r\n          s0 = peg$currPos;\r\n          if (input.substr(peg$currPos, 2) === peg$c103) {\r\n            s1 = peg$c103;\r\n            peg$currPos += 2;\r\n          } else {\r\n            s1 = peg$FAILED;\r\n            if (peg$silentFails === 0) { peg$fail(peg$c104); }\r\n          }\r\n          if (s1 !== peg$FAILED) {\r\n            peg$reportedPos = s0;\r\n            s1 = peg$c105();\r\n          }\r\n          s0 = s1;\r\n          if (s0 === peg$FAILED) {\r\n            s0 = peg$currPos;\r\n            if (input.substr(peg$currPos, 2) === peg$c106) {\r\n              s1 = peg$c106;\r\n              peg$currPos += 2;\r\n            } else {\r\n              s1 = peg$FAILED;\r\n              if (peg$silentFails === 0) { peg$fail(peg$c107); }\r\n            }\r\n            if (s1 !== peg$FAILED) {\r\n              peg$reportedPos = s0;\r\n              s1 = peg$c108();\r\n            }\r\n            s0 = s1;\r\n            if (s0 === peg$FAILED) {\r\n              s0 = peg$currPos;\r\n              if (input.substr(peg$currPos, 2) === peg$c109) {\r\n                s1 = peg$c109;\r\n                peg$currPos += 2;\r\n              } else {\r\n                s1 = peg$FAILED;\r\n                if (peg$silentFails === 0) { peg$fail(peg$c110); }\r\n              }\r\n              if (s1 !== peg$FAILED) {\r\n                peg$reportedPos = s0;\r\n                s1 = peg$c111();\r\n              }\r\n              s0 = s1;\r\n              if (s0 === peg$FAILED) {\r\n                s0 = peg$currPos;\r\n                if (input.substr(peg$currPos, 2) === peg$c112) {\r\n                  s1 = peg$c112;\r\n                  peg$currPos += 2;\r\n                } else {\r\n                  s1 = peg$FAILED;\r\n                  if (peg$silentFails === 0) { peg$fail(peg$c113); }\r\n                }\r\n                if (s1 !== peg$FAILED) {\r\n                  peg$reportedPos = s0;\r\n                  s1 = peg$c114();\r\n                }\r\n                s0 = s1;\r\n                if (s0 === peg$FAILED) {\r\n                  s0 = peg$currPos;\r\n                  if (input.substr(peg$currPos, 2) === peg$c115) {\r\n                    s1 = peg$c115;\r\n                    peg$currPos += 2;\r\n                  } else {\r\n                    s1 = peg$FAILED;\r\n                    if (peg$silentFails === 0) { peg$fail(peg$c116); }\r\n                  }\r\n                  if (s1 !== peg$FAILED) {\r\n                    peg$reportedPos = s0;\r\n                    s1 = peg$c117();\r\n                  }\r\n                  s0 = s1;\r\n                  if (s0 === peg$FAILED) {\r\n                    s0 = peg$parseESCAPED_UNICODE();\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n    function peg$parseESCAPED_UNICODE() {\r\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\r\n\r\n      var key    = peg$currPos * 49 + 48,\r\n          cached = peg$cache[key];\r\n\r\n      if (cached) {\r\n        peg$currPos = cached.nextPos;\r\n        return cached.result;\r\n      }\r\n\r\n      s0 = peg$currPos;\r\n      if (input.substr(peg$currPos, 2) === peg$c118) {\r\n        s1 = peg$c118;\r\n        peg$currPos += 2;\r\n      } else {\r\n        s1 = peg$FAILED;\r\n        if (peg$silentFails === 0) { peg$fail(peg$c119); }\r\n      }\r\n      if (s1 !== peg$FAILED) {\r\n        s2 = peg$currPos;\r\n        s3 = peg$parseHEX();\r\n        if (s3 !== peg$FAILED) {\r\n          s4 = peg$parseHEX();\r\n          if (s4 !== peg$FAILED) {\r\n            s5 = peg$parseHEX();\r\n            if (s5 !== peg$FAILED) {\r\n              s6 = peg$parseHEX();\r\n              if (s6 !== peg$FAILED) {\r\n                s7 = peg$parseHEX();\r\n                if (s7 !== peg$FAILED) {\r\n                  s8 = peg$parseHEX();\r\n                  if (s8 !== peg$FAILED) {\r\n                    s9 = peg$parseHEX();\r\n                    if (s9 !== peg$FAILED) {\r\n                      s10 = peg$parseHEX();\r\n                      if (s10 !== peg$FAILED) {\r\n                        s3 = [s3, s4, s5, s6, s7, s8, s9, s10];\r\n                        s2 = s3;\r\n                      } else {\r\n                        peg$currPos = s2;\r\n                        s2 = peg$c2;\r\n                      }\r\n                    } else {\r\n                      peg$currPos = s2;\r\n                      s2 = peg$c2;\r\n                    }\r\n                  } else {\r\n                    peg$currPos = s2;\r\n                    s2 = peg$c2;\r\n                  }\r\n                } else {\r\n                  peg$currPos = s2;\r\n                  s2 = peg$c2;\r\n                }\r\n              } else {\r\n                peg$currPos = s2;\r\n                s2 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s2;\r\n              s2 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s2;\r\n            s2 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s2;\r\n          s2 = peg$c2;\r\n        }\r\n        if (s2 !== peg$FAILED) {\r\n          peg$reportedPos = s0;\r\n          s1 = peg$c120(s2);\r\n          s0 = s1;\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      } else {\r\n        peg$currPos = s0;\r\n        s0 = peg$c2;\r\n      }\r\n      if (s0 === peg$FAILED) {\r\n        s0 = peg$currPos;\r\n        if (input.substr(peg$currPos, 2) === peg$c121) {\r\n          s1 = peg$c121;\r\n          peg$currPos += 2;\r\n        } else {\r\n          s1 = peg$FAILED;\r\n          if (peg$silentFails === 0) { peg$fail(peg$c122); }\r\n        }\r\n        if (s1 !== peg$FAILED) {\r\n          s2 = peg$currPos;\r\n          s3 = peg$parseHEX();\r\n          if (s3 !== peg$FAILED) {\r\n            s4 = peg$parseHEX();\r\n            if (s4 !== peg$FAILED) {\r\n              s5 = peg$parseHEX();\r\n              if (s5 !== peg$FAILED) {\r\n                s6 = peg$parseHEX();\r\n                if (s6 !== peg$FAILED) {\r\n                  s3 = [s3, s4, s5, s6];\r\n                  s2 = s3;\r\n                } else {\r\n                  peg$currPos = s2;\r\n                  s2 = peg$c2;\r\n                }\r\n              } else {\r\n                peg$currPos = s2;\r\n                s2 = peg$c2;\r\n              }\r\n            } else {\r\n              peg$currPos = s2;\r\n              s2 = peg$c2;\r\n            }\r\n          } else {\r\n            peg$currPos = s2;\r\n            s2 = peg$c2;\r\n          }\r\n          if (s2 !== peg$FAILED) {\r\n            peg$reportedPos = s0;\r\n            s1 = peg$c120(s2);\r\n            s0 = s1;\r\n          } else {\r\n            peg$currPos = s0;\r\n            s0 = peg$c2;\r\n          }\r\n        } else {\r\n          peg$currPos = s0;\r\n          s0 = peg$c2;\r\n        }\r\n      }\r\n\r\n      peg$cache[key] = { nextPos: peg$currPos, result: s0 };\r\n\r\n      return s0;\r\n    }\r\n\r\n\r\n      var nodes = [];\r\n\r\n      function genError(err, line, col) {\r\n        var ex = new Error(err);\r\n        ex.line = line;\r\n        ex.column = col;\r\n        throw ex;\r\n      }\r\n\r\n      function addNode(node) {\r\n        nodes.push(node);\r\n      }\r\n\r\n      function node(type, value, line, column, key) {\r\n        var obj = { type: type, value: value, line: line(), column: column() };\r\n        if (key) obj.key = key;\r\n        return obj;\r\n      }\r\n\r\n      function convertCodePoint(str, line, col) {\r\n        var num = parseInt(\"0x\" + str);\r\n\r\n        if (\r\n          !isFinite(num) ||\r\n          Math.floor(num) != num ||\r\n          num < 0 ||\r\n          num > 0x10FFFF ||\r\n          (num > 0xD7FF && num < 0xE000)\r\n        ) {\r\n          genError(\"Invalid Unicode escape code: \" + str, line, col);\r\n        } else {\r\n          return fromCodePoint(num);\r\n        }\r\n      }\r\n\r\n      function fromCodePoint() {\r\n        var MAX_SIZE = 0x4000;\r\n        var codeUnits = [];\r\n        var highSurrogate;\r\n        var lowSurrogate;\r\n        var index = -1;\r\n        var length = arguments.length;\r\n        if (!length) {\r\n          return '';\r\n        }\r\n        var result = '';\r\n        while (++index < length) {\r\n          var codePoint = Number(arguments[index]);\r\n          if (codePoint <= 0xFFFF) { // BMP code point\r\n            codeUnits.push(codePoint);\r\n          } else { // Astral code point; split in surrogate halves\r\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\r\n            codePoint -= 0x10000;\r\n            highSurrogate = (codePoint >> 10) + 0xD800;\r\n            lowSurrogate = (codePoint % 0x400) + 0xDC00;\r\n            codeUnits.push(highSurrogate, lowSurrogate);\r\n          }\r\n          if (index + 1 == length || codeUnits.length > MAX_SIZE) {\r\n            result += String.fromCharCode.apply(null, codeUnits);\r\n            codeUnits.length = 0;\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n\r\n\r\n    peg$result = peg$startRuleFunction();\r\n\r\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\r\n      return peg$result;\r\n    } else {\r\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\r\n        peg$fail({ type: \"end\", description: \"end of input\" });\r\n      }\r\n\r\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\r\n    }\r\n  }\r\n\r\n  return {\r\n    SyntaxError: SyntaxError,\r\n    parse:       parse\r\n  };\r\n})();\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/toml/lib/parser.js\n// module id = 13\n// module chunks = 0 1 2","\"use strict\";\r\nfunction compile(nodes) {\r\n  var assignedPaths = [];\r\n  var valueAssignments = [];\r\n  var currentPath = \"\";\r\n  var data = {};\r\n  var context = data;\r\n  var arrayMode = false;\r\n\r\n  return reduce(nodes);\r\n\r\n  function reduce(nodes) {\r\n    var node;\r\n    for (var i in nodes) {\r\n      node = nodes[i];\r\n      switch (node.type) {\r\n      case \"Assign\":\r\n        assign(node);\r\n        break;\r\n      case \"ObjectPath\":\r\n        setPath(node);\r\n        break;\r\n      case \"ArrayPath\":\r\n        addTableArray(node);\r\n        break;\r\n      }\r\n    }\r\n\r\n    return data;\r\n  }\r\n\r\n  function genError(err, line, col) {\r\n    var ex = new Error(err);\r\n    ex.line = line;\r\n    ex.column = col;\r\n    throw ex;\r\n  }\r\n\r\n  function assign(node) {\r\n    var key = node.key;\r\n    var value = node.value;\r\n    var line = node.line;\r\n    var column = node.column;\r\n\r\n    var fullPath;\r\n    if (currentPath) {\r\n      fullPath = currentPath + \".\" + key;\r\n    } else {\r\n      fullPath = key;\r\n    }\r\n    if (typeof context[key] !== \"undefined\") {\r\n      genError(\"Cannot redefine existing key '\" + fullPath + \"'.\", line, column);\r\n    }\r\n\r\n    context[key] = reduceValueNode(value);\r\n\r\n    if (!pathAssigned(fullPath)) {\r\n      assignedPaths.push(fullPath);\r\n      valueAssignments.push(fullPath);\r\n    }\r\n  }\r\n\r\n\r\n  function pathAssigned(path) {\r\n    return assignedPaths.indexOf(path) !== -1;\r\n  }\r\n\r\n  function reduceValueNode(node) {\r\n    if (node.type === \"Array\") {\r\n      return reduceArrayWithTypeChecking(node.value);\r\n    } else if (node.type === \"InlineTable\") {\r\n      return reduceInlineTableNode(node.value);\r\n    } else {\r\n      return node.value;\r\n    }\r\n  }\r\n\r\n  function reduceInlineTableNode(values) {\r\n    var obj = {};\r\n    for (var i = 0; i < values.length; i++) {\r\n      var val = values[i];\r\n      if (val.value.type === \"InlineTable\") {\r\n        obj[val.key] = reduceInlineTableNode(val.value.value);\r\n      } else if (val.type === \"InlineTableValue\") {\r\n        obj[val.key] = reduceValueNode(val.value);\r\n      }\r\n    }\r\n\r\n    return obj;\r\n  }\r\n\r\n  function setPath(node) {\r\n    var path = node.value;\r\n    var quotedPath = path.map(quoteDottedString).join(\".\");\r\n    var line = node.line;\r\n    var column = node.column;\r\n\r\n    if (pathAssigned(quotedPath)) {\r\n      genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\r\n    }\r\n    assignedPaths.push(quotedPath);\r\n    context = deepRef(data, path, {}, line, column);\r\n    currentPath = path;\r\n  }\r\n\r\n  function addTableArray(node) {\r\n    var path = node.value;\r\n    var quotedPath = path.map(quoteDottedString).join(\".\");\r\n    var line = node.line;\r\n    var column = node.column;\r\n\r\n    if (!pathAssigned(quotedPath)) {\r\n      assignedPaths.push(quotedPath);\r\n    }\r\n    assignedPaths = assignedPaths.filter(function(p) {\r\n      return p.indexOf(quotedPath) !== 0;\r\n    });\r\n    assignedPaths.push(quotedPath);\r\n    context = deepRef(data, path, [], line, column);\r\n    currentPath = quotedPath;\r\n\r\n    if (context instanceof Array) {\r\n      var newObj = {};\r\n      context.push(newObj);\r\n      context = newObj;\r\n    } else {\r\n      genError(\"Cannot redefine existing key '\" + path + \"'.\", line, column);\r\n    }\r\n  }\r\n\r\n  // Given a path 'a.b.c', create (as necessary) `start.a`,\r\n  // `start.a.b`, and `start.a.b.c`, assigning `value` to `start.a.b.c`.\r\n  // If `a` or `b` are arrays and have items in them, the last item in the\r\n  // array is used as the context for the next sub-path.\r\n  function deepRef(start, keys, value, line, column) {\r\n    var key;\r\n    var traversed = [];\r\n    var traversedPath = \"\";\r\n    var path = keys.join(\".\");\r\n    var ctx = start;\r\n    var keysLen = keys.length;\r\n\r\n    for (var i in keys) {\r\n      key = keys[i];\r\n      traversed.push(key);\r\n      traversedPath = traversed.join(\".\");\r\n      if (typeof ctx[key] === \"undefined\") {\r\n        if (i === String(keysLen - 1)) {\r\n          ctx[key] = value;\r\n        } else {\r\n          ctx[key] = {};\r\n        }\r\n      } else if (i !== keysLen - 1 && valueAssignments.indexOf(traversedPath) > -1) {\r\n        // already a non-object value at key, can't be used as part of a new path\r\n        genError(\"Cannot redefine existing key '\" + traversedPath + \"'.\", line, column);\r\n      }\r\n\r\n      ctx = ctx[key];\r\n      if (ctx instanceof Array && ctx.length && i < keys.length - 1) {\r\n        ctx = ctx[ctx.length - 1];\r\n      }\r\n    }\r\n\r\n    return ctx;\r\n  }\r\n\r\n  function reduceArrayWithTypeChecking(array) {\r\n    // Ensure that all items in the array are of the same type\r\n    var firstType = null;\r\n    for(var i in array) {\r\n      var node = array[i];\r\n      if (firstType === null) {\r\n        firstType = node.type;\r\n      } else if ((node.type === \"Integer\" || node.type === \"Float\") && (firstType === \"Integer\" || firstType === \"Float\")) {\r\n        // OK.\r\n      } else if (node.type !== firstType) {\r\n        genError(\"Cannot add value of type \" + node.type + \" to array of type \" +\r\n          firstType + \".\", node.line, node.column);\r\n      }\r\n    }\r\n\r\n    // Recursively reduce array of nodes into array of the nodes' values\r\n    return array.map(reduceValueNode);\r\n  }\r\n\r\n  function quoteDottedString(str) {\r\n    if (str.indexOf(\".\") > -1) {\r\n      return \"\\\"\" + str + \"\\\"\";\r\n    } else {\r\n      return str;\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  compile: compile\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/toml/lib/compiler.js\n// module id = 14\n// module chunks = 0 1 2","import { uuid } from 'anno-ui/src/utils'\r\nimport AbstractAnnotation from './abstract'\r\nimport { convertFromExportY } from '../../../shared/coords'\r\nimport appendChild from '../render/appendChild'\r\n\r\n/**\r\n * Span Annotation.\r\n */\r\nexport default class SpanAnnotation extends AbstractAnnotation {\r\n\r\n  /**\r\n   * Constructor.\r\n   */\r\n  constructor () {\r\n    super()\r\n\r\n    this.uuid         = null\r\n    this.type         = 'span'\r\n    this.rectangles   = []\r\n    this.text         = null\r\n    this.color        = null\r\n    this.readOnly     = false\r\n    this.selectedText = null\r\n    this.textRange    = null\r\n    this.page         = null\r\n    this.knob         = true\r\n    this.border       = true\r\n    this.$element     = this.createDummyElement()\r\n\r\n    window.globalEvent.on('deleteSelectedAnnotation', this.deleteSelectedAnnotation)\r\n    window.globalEvent.on('enableViewMode', this.enableViewMode)\r\n  }\r\n\r\n  /**\r\n   * Create an instance from an annotation data.\r\n   */\r\n  static newInstance (annotation) {\r\n    let a          = new SpanAnnotation()\r\n    a.uuid         = annotation.uuid || uuid()\r\n    a.text         = annotation.text\r\n    a.color        = annotation.color\r\n    a.readOnly     = annotation.readOnly || false\r\n    a.selectedText = annotation.selectedText\r\n    a.textRange    = annotation.textRange\r\n    a.page         = annotation.page\r\n    a.zIndex       = annotation.zIndex || 10\r\n    a.knob         = (typeof annotation.knob === 'boolean' ? annotation.knob : true)\r\n    a.border       = annotation.border !== false\r\n\r\n    // Calc the position.\r\n    let rects = window.findTexts(a.page, a.textRange[0], a.textRange[1])\r\n    rects = window.mergeRects(rects)\r\n    a.rectangles = rects\r\n\r\n    return a\r\n  }\r\n\r\n  /**\r\n   * Create an instance from a TOML object.\r\n   */\r\n  static newInstanceFromTomlObject (tomlObject) {\r\n    let d = tomlObject\r\n    d.selectedText = d.text\r\n    d.text = d.label\r\n    d.textRange = d.textrange\r\n    let span = SpanAnnotation.newInstance(d)\r\n    return span\r\n  }\r\n\r\n  /**\r\n   * Render annotation(s).\r\n   */\r\n  render () {\r\n\r\n    if (!this.rectangles || this.rectangles.length === 0) {\r\n      if (!this.page || !this.textRange) {\r\n        return console.log('ERROR: span missing page or textRange. span=', this)\r\n      }\r\n      let rects = window.findTexts(this.page, this.textRange[0], this.textRange[1])\r\n      rects = window.mergeRects(rects)\r\n      this.rectangles = rects\r\n    }\r\n\r\n    return super.render()\r\n  }\r\n\r\n\r\n  /**\r\n   * Set a hover event.\r\n   */\r\n  setHoverEvent () {\r\n    this.$element.find('.anno-knob').hover(\r\n      this.handleHoverInEvent,\r\n      this.handleHoverOutEvent\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Delete the annotation from rendering, a container in window, and a container in localStorage.\r\n   */\r\n  destroy () {\r\n    let promise = super.destroy()\r\n    this.emit('delete')\r\n\r\n    // TODO .\r\n    window.globalEvent.removeListener('deleteSelectedAnnotation', this.deleteSelectedAnnotation)\r\n    window.globalEvent.removeListener('enableViewMode', this.enableViewMode)\r\n    return promise\r\n  }\r\n\r\n  /**\r\n   * Create an annotation data for save.\r\n   */\r\n  createAnnotation () {\r\n    return {\r\n      uuid         : this.uuid,\r\n      type         : this.type,\r\n      rectangles   : this.rectangles,\r\n      text         : this.text,\r\n      color        : this.color,\r\n      readyOnly    : this.readOnly,\r\n      selectedText : this.selectedText\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the position for text.\r\n   */\r\n  getTextPosition () {\r\n\r\n    let p = null\r\n\r\n    if (this.rectangles.length > 0) {\r\n      p = {\r\n        x : this.rectangles[0].x + 7,\r\n        y : this.rectangles[0].y - 20\r\n      }\r\n    }\r\n\r\n    return p\r\n  }\r\n\r\n  /**\r\n   * Delete the annotation if selected.\r\n   */\r\n  deleteSelectedAnnotation () {\r\n    super.deleteSelectedAnnotation()\r\n  }\r\n\r\n  /**\r\n   * Handle a selected event on a text.\r\n   */\r\n  handleTextSelected () {\r\n    this.select()\r\n  }\r\n\r\n  /**\r\n   * Handle a deselected event on a text.\r\n   */\r\n  handleTextDeselected () {\r\n    this.deselect()\r\n  }\r\n\r\n  /**\r\n   * Handle a hovein event on a text.\r\n   */\r\n  handleTextHoverIn () {\r\n    this.highlight()\r\n    this.emit('hoverin')\r\n  }\r\n\r\n  /**\r\n   * Handle a hoveout event on a text.\r\n   */\r\n  handleTextHoverOut () {\r\n    this.dehighlight()\r\n    this.emit('hoverout')\r\n  }\r\n\r\n  /**\r\n   * Save a new text.\r\n   */\r\n  handleTextChanged (newText) {\r\n    this.text = newText\r\n    this.save()\r\n  }\r\n\r\n  /**\r\n   * Handle a hoverin event.\r\n   */\r\n  handleHoverInEvent (e) {\r\n    super.handleHoverInEvent(e)\r\n    this.emit('circlehoverin', this)\r\n  }\r\n\r\n  /**\r\n   * Handle a hoverout event.\r\n   */\r\n  handleHoverOutEvent (e) {\r\n    super.handleHoverOutEvent(e)\r\n    this.emit('circlehoverout', this)\r\n  }\r\n\r\n  /**\r\n   * Handle a click event.\r\n   */\r\n  handleClickEvent (e) {\r\n    super.handleClickEvent(e)\r\n  }\r\n\r\n  export () {\r\n\r\n    let text = (this.selectedText || '')\r\n      .replace(/\\r\\n/g, ' ')\r\n      .replace(/\\r/g, ' ')\r\n      .replace(/\\n/g, ' ')\r\n      .replace(/\"/g, '')\r\n      .replace(/\\\\/g, '')\r\n\r\n    return {\r\n      type      : this.type,\r\n      page      : this.page,\r\n      label     : this.text || '',\r\n      text,\r\n      textrange : this.textRange\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enable view mode.\r\n   */\r\n  enableViewMode () {\r\n    this.disableViewMode()\r\n    super.enableViewMode()\r\n    if (!this.readOnly) {\r\n      this.$element.find('.anno-knob').on('click', this.handleClickEvent)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disable view mode.\r\n   */\r\n  disableViewMode () {\r\n    super.disableViewMode()\r\n    this.$element.find('.anno-knob').off('click')\r\n  }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/annotation/span.js\n// module id = 48\n// module chunks = 2","import EventEmitter from 'events'\r\nimport appendChild from '../render/appendChild'\r\nimport { dispatchWindowEvent } from '../utils/event'\r\n\r\n/**\r\n * Abstract Annotation Class.\r\n */\r\nexport default class AbstractAnnotation extends EventEmitter {\r\n\r\n  /**\r\n   * Check the argument is an annotation.\r\n   */\r\n  static isAnnotation (obj) {\r\n    return obj && obj.uuid && obj.type\r\n  }\r\n\r\n  /**\r\n   * Constructor.\r\n   */\r\n  constructor () {\r\n    super()\r\n    this.autoBind()\r\n    this.deleted = false\r\n    this.selected = false\r\n    this.selectedTime = null\r\n    this.createdAt = new Date().getTime()\r\n  }\r\n\r\n  /**\r\n   * Bind the `this` scope of instance methods to `this`.\r\n   */\r\n  autoBind () {\r\n    Object.getOwnPropertyNames(this.constructor.prototype)\r\n      .filter(prop => typeof this[prop] === 'function')\r\n      .forEach(method => {\r\n        this[method] = this[method].bind(this)\r\n      })\r\n  }\r\n\r\n  /**\r\n   * Render annotation(s).\r\n   */\r\n  render () {\r\n\r\n    this.$element.remove()\r\n\r\n    if (this.deleted) {\r\n      return false\r\n    }\r\n\r\n    const base = $('#annoLayer2')[0]\r\n    this.$element = $(appendChild(base, this))\r\n\r\n    if (!this.hoverEventDisable && this.setHoverEvent) {\r\n      this.setHoverEvent()\r\n    }\r\n\r\n    this.selected && this.$element.addClass('--selected')\r\n\r\n    this.disabled && this.disable()\r\n\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * Save the annotation data.\r\n   */\r\n  save () {\r\n    window.annotationContainer.add(this)\r\n  }\r\n\r\n  /**\r\n   * Delete the annotation from rendering, a container in window, and a container in localStorage.\r\n   */\r\n  destroy () {\r\n    this.deleted = true\r\n    this.$element.remove()\r\n\r\n    let promise = Promise.resolve()\r\n\r\n    if (this.uuid) {\r\n      window.annotationContainer.remove(this)\r\n    }\r\n\r\n    return promise\r\n  }\r\n\r\n  /**\r\n   * Judge the point within the element.\r\n   */\r\n  isHit (x, y) {\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Handle a click event.\r\n   */\r\n  handleClickEvent (e) {\r\n    this.toggleSelect()\r\n\r\n    if (this.type !== 'textbox') {\r\n\r\n      if (this.selected) {\r\n\r\n        // TODO Use common function.\r\n        let event = document.createEvent('CustomEvent')\r\n        event.initCustomEvent('annotationSelected', true, true, this)\r\n        window.dispatchEvent(event)\r\n\r\n      } else {\r\n\r\n        // TODO Use common function.\r\n        let event = document.createEvent('CustomEvent')\r\n        event.initCustomEvent('annotationDeselected', true, true, this)\r\n        window.dispatchEvent(event)\r\n\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle a hoverIn event.\r\n   */\r\n  handleHoverInEvent (e) {\r\n    console.log('handleHoverInEvent')\r\n    this.highlight()\r\n    this.emit('hoverin')\r\n    dispatchWindowEvent('annotationHoverIn', this)\r\n  }\r\n\r\n  /**\r\n   * Handle a hoverOut event.\r\n   */\r\n  handleHoverOutEvent (e) {\r\n    console.log('handleHoverOutEvent')\r\n    this.dehighlight()\r\n    this.emit('hoverout')\r\n    dispatchWindowEvent('annotationHoverOut', this)\r\n  }\r\n\r\n  /**\r\n   * Highlight the annotation.\r\n   */\r\n  highlight () {\r\n    this.$element.addClass('--hover')\r\n  }\r\n\r\n  /**\r\n   * Dehighlight the annotation.\r\n   */\r\n  dehighlight () {\r\n    this.$element.removeClass('--hover')\r\n  }\r\n\r\n  /**\r\n   * Select the annotation.\r\n   */\r\n  select () {\r\n    this.selected = true\r\n    this.selectedTime = Date.now()\r\n    this.$element.addClass('--selected')\r\n  }\r\n\r\n  /**\r\n   * Deselect the annotation.\r\n   */\r\n  deselect () {\r\n    console.log('deselect')\r\n    this.selected = false\r\n    this.selectedTime = null\r\n    this.$element.removeClass('--selected')\r\n  }\r\n\r\n  /**\r\n   * Toggle the selected state.\r\n   */\r\n  toggleSelect () {\r\n\r\n    if (this.selected) {\r\n      this.deselect()\r\n    } else {\r\n      this.select()\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * Delete the annotation if selected.\r\n   */\r\n  deleteSelectedAnnotation () {\r\n\r\n    if (this.isSelected()) {\r\n      this.destroy().then(() => {\r\n        dispatchWindowEvent('annotationDeleted', { uuid : this.uuid })\r\n      })\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Check whether the annotation is selected.\r\n   */\r\n  isSelected () {\r\n    return this.$element.hasClass('--selected')\r\n  }\r\n\r\n  /**\r\n   * Create a dummy DOM element for the timing that a annotation hasn't be specified yet.\r\n   */\r\n  createDummyElement () {\r\n    return $('<div class=\"dummy\"/>')\r\n  }\r\n\r\n  /**\r\n   * Get the central position of the boundingCircle.\r\n   */\r\n  getBoundingCirclePosition () {\r\n    const $circle = this.$element.find('.anno-knob')\r\n    if ($circle.length > 0) {\r\n      return {\r\n        x : parseFloat($circle.css('left')) + parseFloat($circle.css('width')) / 2,\r\n        y : parseFloat($circle.css('top')) + parseFloat($circle.css('height')) / 2\r\n      }\r\n    }\r\n    return null\r\n  }\r\n\r\n  /**\r\n   * Enable a view mode.\r\n   */\r\n  enableViewMode () {\r\n    this.render()\r\n  }\r\n\r\n  /**\r\n   * Disable a view mode.\r\n   */\r\n  disableViewMode () {\r\n    this.render()\r\n  }\r\n\r\n  setDisableHoverEvent () {\r\n    this.hoverEventDisable = true\r\n  }\r\n\r\n  setEnableHoverEvent () {\r\n    this.hoverEventDisable = false\r\n  }\r\n\r\n  enable () {\r\n    this.disabled = false\r\n    this.$element.css('pointer-events', 'auto')\r\n  }\r\n\r\n  disable () {\r\n    this.disabled = true\r\n    this.$element.css('pointer-events', 'none')\r\n  }\r\n\r\n  /**\r\n   * Check the another annotation is equal to `this`.\r\n   */\r\n  equalTo (anotherAnnotation) {\r\n    // Implement Here.\r\n    return false\r\n  }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/annotation/abstract.js\n// module id = 49\n// module chunks = 2","\r\n/**\r\n * Circle radius.\r\n */\r\nexport const DEFAULT_RADIUS = 7\r\n\r\n/**\r\n * Create a bounding circle.\r\n * @param {Object} the data for rendering.\r\n */\r\nexport function renderKnob ({ x, y, readOnly }) {\r\n\r\n  // Adjust the position.\r\n  [x, y] = adjustPoint(x, (y - (DEFAULT_RADIUS + 2)), DEFAULT_RADIUS)\r\n\r\n  // Set the CSS class.\r\n  let cssClass = 'anno-knob'\r\n  if (readOnly) {\r\n    cssClass += ' is-readonly'\r\n  }\r\n\r\n  // Create a knob.\r\n  return $(`<div class=\"${cssClass}\"/>`).css({\r\n    top    : `${y}px`,\r\n    left   : `${x}px`,\r\n    width  : DEFAULT_RADIUS + 'px',\r\n    height : DEFAULT_RADIUS + 'px'\r\n  })\r\n}\r\n\r\n/**\r\n * Adjust the circle position not overlay anothers.\r\n */\r\nfunction adjustPoint (x, y, radius) {\r\n\r\n  // Get all knobs.\r\n  const $circles = $('.anno-knob')\r\n\r\n  // Find a position where all knobs are not placed at.\r\n  while (true) {\r\n    let good = true\r\n    $circles.each(function () {\r\n      const $this = $(this)\r\n      const x1 = parseInt($this.css('left'))\r\n      const y1 = parseInt($this.css('top'))\r\n      const distance1 = Math.pow(x - x1, 2) + Math.pow(y - y1, 2)\r\n      const distance2 = Math.pow(radius, 2)\r\n      if (distance1 < distance2) {\r\n        good = false\r\n      }\r\n    })\r\n    if (good) {\r\n      break\r\n    }\r\n    y -= 1\r\n  }\r\n  return [x, y]\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/render/renderKnob.js\n// module id = 50\n// module chunks = 2","import { uuid } from 'anno-ui/src/utils'\r\nimport AbstractAnnotation from './abstract'\r\nimport { getRelationTextPosition } from '../utils/relation.js'\r\nimport { anyOf } from '../../../shared/util'\r\n\r\nlet globalEvent\r\n\r\n/**\r\n * Relation Annotation (one-way / two-way / link)\r\n */\r\nexport default class RelationAnnotation extends AbstractAnnotation {\r\n\r\n  /**\r\n   * Constructor.\r\n   */\r\n  constructor () {\r\n    super()\r\n\r\n    globalEvent = window.globalEvent\r\n\r\n    this.uuid = uuid()\r\n    this.type = 'relation'\r\n    this.direction = null\r\n    this.rel1Annotation = null\r\n    this.rel2Annotation = null\r\n    this.text = null\r\n    this.color = null\r\n    this.readOnly = false\r\n    this.$element = this.createDummyElement()\r\n\r\n    // for render.\r\n    this.x1 = 0\r\n    this.y1 = 0\r\n    this.x2 = 0\r\n    this.y2 = 0\r\n\r\n    globalEvent.on('deleteSelectedAnnotation', this.deleteSelectedAnnotation)\r\n    globalEvent.on('enableViewMode', this.enableViewMode)\r\n    globalEvent.on('rectmoveend', this.handleRelMoveEnd)\r\n  }\r\n\r\n  /**\r\n   * Create an instance from an annotation data.\r\n   */\r\n  static newInstance (annotation) {\r\n    let a            = new RelationAnnotation()\r\n    a.uuid           = annotation.uuid || uuid()\r\n    a.direction      = annotation.direction\r\n    a.rel1Annotation = AbstractAnnotation.isAnnotation(annotation.rel1) ? annotation.rel1 : window.annotationContainer.findById(annotation.rel1)\r\n    a.rel2Annotation = AbstractAnnotation.isAnnotation(annotation.rel2) ? annotation.rel2 : window.annotationContainer.findById(annotation.rel2)\r\n    a.text           = annotation.text\r\n    a.color          = annotation.color\r\n    a.readOnly       = annotation.readOnly || false\r\n    a.zIndex         = annotation.zIndex || 10\r\n    return a\r\n  }\r\n\r\n  /**\r\n   * Create an instance from a TOML object.\r\n   */\r\n  static newInstanceFromTomlObject (d) {\r\n    d.direction = d.dir\r\n    // TODO Annotationlabel\r\n    d.text = d.label\r\n    let rel = RelationAnnotation.newInstance(d)\r\n    return rel\r\n  }\r\n\r\n  /**\r\n   * Set a hover event.\r\n   */\r\n  setHoverEvent () {\r\n    this.$element.find('path').hover(\r\n      this.handleHoverInEvent,\r\n      this.handleHoverOutEvent\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Setter - rel1Annotation.\r\n   */\r\n  set rel1Annotation (a) {\r\n    this._rel1Annotation = a\r\n    if (this._rel1Annotation) {\r\n      this._rel1Annotation.on('hoverin', this.handleRelHoverIn)\r\n      this._rel1Annotation.on('hoverout', this.handleRelHoverOut)\r\n      this._rel1Annotation.on('rectmove', this.handleRelMove)\r\n      this._rel1Annotation.on('delete', this.handleRelDelete)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Getter - rel1Annotation.\r\n   */\r\n  get rel1Annotation () {\r\n    return this._rel1Annotation\r\n  }\r\n\r\n  /**\r\n   * Setter - rel2Annotation.\r\n   */\r\n  set rel2Annotation (a) {\r\n    this._rel2Annotation = a\r\n    if (this._rel2Annotation) {\r\n      this._rel2Annotation.on('hoverin', this.handleRelHoverIn)\r\n      this._rel2Annotation.on('hoverout', this.handleRelHoverOut)\r\n      this._rel2Annotation.on('rectmove', this.handleRelMove)\r\n      this._rel2Annotation.on('delete', this.handleRelDelete)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Getter - rel2Annotation.\r\n   */\r\n  get rel2Annotation () {\r\n    return this._rel2Annotation\r\n  }\r\n\r\n  /**\r\n   * Render the annotation.\r\n   */\r\n  render () {\r\n    this.setStartEndPosition()\r\n    super.render()\r\n  }\r\n\r\n  /**\r\n   * Create an annotation data for save.\r\n   */\r\n  createAnnotation () {\r\n    return {\r\n      uuid      : this.uuid,\r\n      type      : this.type,\r\n      direction : this.direction,\r\n      rel1      : this._rel1Annotation.uuid,\r\n      rel2      : this._rel2Annotation.uuid,\r\n      text      : this.text,\r\n      color     : this.color,\r\n      readOnly  : this.readOnly\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroy the annotation.\r\n   */\r\n  destroy () {\r\n    let promise = super.destroy()\r\n    if (this._rel1Annotation) {\r\n      this._rel1Annotation.removeListener('hoverin', this.handleRelHoverIn)\r\n      this._rel1Annotation.removeListener('hoverout', this.handleRelHoverOut)\r\n      this._rel1Annotation.removeListener('rectmove', this.handleRelMove)\r\n      this._rel1Annotation.removeListener('delete', this.handleRelDelete)\r\n      delete this._rel1Annotation\r\n    }\r\n    if (this._rel2Annotation) {\r\n      this._rel2Annotation.removeListener('hoverin', this.handleRelHoverIn)\r\n      this._rel2Annotation.removeListener('hoverout', this.handleRelHoverOut)\r\n      this._rel2Annotation.removeListener('rectmove', this.handleRelMove)\r\n      this._rel2Annotation.removeListener('delete', this.handleRelDelete)\r\n      delete this._rel2Annotation\r\n    }\r\n\r\n    globalEvent.removeListener('deleteSelectedAnnotation', this.deleteSelectedAnnotation)\r\n    globalEvent.removeListener('enableViewMode', this.enableViewMode)\r\n    globalEvent.removeListener('rectmoveend', this.handleRelMoveEnd)\r\n\r\n    return promise\r\n  }\r\n\r\n  /**\r\n   * Delete the annotation if selected.\r\n   */\r\n  deleteSelectedAnnotation () {\r\n    super.deleteSelectedAnnotation()\r\n  }\r\n\r\n  /**\r\n   * Get the position for text.\r\n   */\r\n  // TODO No need ?\r\n  getTextPosition () {\r\n    this.setStartEndPosition()\r\n    return getRelationTextPosition(this.x1, this.y1, this.x2, this.y2, this.text, this.uuid)\r\n  }\r\n\r\n  /**\r\n   * Highlight relations.\r\n   */\r\n  highlightRelAnnotations () {\r\n    if (this._rel1Annotation) {\r\n      this._rel1Annotation.highlight()\r\n    }\r\n    if (this._rel2Annotation) {\r\n      this._rel2Annotation.highlight()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Dehighlight relations.\r\n   */\r\n  dehighlightRelAnnotations () {\r\n    if (this._rel1Annotation) {\r\n      this._rel1Annotation.dehighlight()\r\n    }\r\n    if (this.rel2Annotation) {\r\n      this.rel2Annotation.dehighlight()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle a selected event on a text.\r\n   */\r\n  handleTextSelected () {\r\n    this.select()\r\n  }\r\n\r\n  /**\r\n   * Handle a deselected event on a text.\r\n   */\r\n  handleTextDeselected () {\r\n    this.deselect()\r\n  }\r\n\r\n  /**\r\n   * The callback for the relational text hoverred in.\r\n   */\r\n  handleTextHoverIn () {\r\n    this.highlight()\r\n    this.emit('hoverin')\r\n    this.highlightRelAnnotations()\r\n  }\r\n\r\n  /**\r\n   * The callback for the relational text hoverred out.\r\n   */\r\n  handleTextHoverOut () {\r\n    this.dehighlight()\r\n    this.emit('hoverout')\r\n    this.dehighlightRelAnnotations()\r\n  }\r\n\r\n  /**\r\n   * The callback for the relationals hoverred in.\r\n   */\r\n  handleRelHoverIn () {\r\n    this.highlight()\r\n    this.highlightRelAnnotations()\r\n  }\r\n\r\n  /**\r\n   * The callback for the relationals hoverred out.\r\n   */\r\n  handleRelHoverOut () {\r\n    this.dehighlight()\r\n    this.dehighlightRelAnnotations()\r\n  }\r\n\r\n  /**\r\n   * The callback that is called relations has benn deleted.\r\n   */\r\n  handleRelDelete () {\r\n    this.destroy()\r\n  }\r\n\r\n  /**\r\n   * The callback that is called relations has been moved.\r\n   */\r\n  handleRelMove () {\r\n    this.render()\r\n  }\r\n\r\n  /**\r\n   * The callback that is called relations has finished to be moved.\r\n   */\r\n  handleRelMoveEnd (rectAnnotation) {\r\n    if (this._rel1Annotation === rectAnnotation || this._rel2Annotation === rectAnnotation) {\r\n      this.enableViewMode()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The callback that is called the text content is changed.\r\n   *\r\n   * @param {String} newText - the content an user changed.\r\n   */\r\n  handleTextChanged (newText) {\r\n    this.text = newText\r\n    this.save()\r\n  }\r\n\r\n  /**\r\n   * The callback that is called at hoverred in.\r\n   */\r\n  handleHoverInEvent (e) {\r\n    super.handleHoverInEvent(e)\r\n    this.highlightRelAnnotations()\r\n  }\r\n\r\n  /**\r\n   * The callback that is called at hoverred out.\r\n   */\r\n  handleHoverOutEvent (e) {\r\n    super.handleHoverOutEvent(e)\r\n    this.dehighlightRelAnnotations()\r\n  }\r\n\r\n  /**\r\n   * The callback that is called at clicked.\r\n   */\r\n  handleClickEvent (e) {\r\n    super.handleClickEvent(e)\r\n  }\r\n\r\n  /**\r\n   * Export Data for TOML.\r\n   * @returns {{type: string, dir: null, ids: *[], label: *|string}}\r\n   */\r\n  export () {\r\n    return {\r\n      type  : this.type,\r\n      dir   : this.direction,\r\n      ids   : [ this.rel1Annotation.exportId, this.rel2Annotation.exportId ],\r\n      label : this.text || ''\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enable view mode.\r\n   */\r\n  enableViewMode () {\r\n\r\n    this.disableViewMode()\r\n\r\n    super.enableViewMode()\r\n\r\n    if (!this.readOnly) {\r\n      this.$element.find('path').on('click', this.handleClickEvent)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disable view mode.\r\n   */\r\n  disableViewMode () {\r\n    super.disableViewMode()\r\n    this.$element.find('path').off('click')\r\n  }\r\n\r\n  /**\r\n   * Set the start / end points of the relation.\r\n   */\r\n  setStartEndPosition () {\r\n    if (this._rel1Annotation) {\r\n      let p = this._rel1Annotation.getBoundingCirclePosition()\r\n      this.x1 = p.x\r\n      this.y1 = p.y\r\n    }\r\n    if (this._rel2Annotation) {\r\n      let p = this._rel2Annotation.getBoundingCirclePosition()\r\n      this.x2 = p.x\r\n      this.y2 = p.y\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @{inheritDoc}\r\n   */\r\n  equalTo (anno) {\r\n\r\n    if (!anno || this.type !== anno) {\r\n      return false\r\n    }\r\n\r\n    const isSame = anyOf(this.rel1Annotation.uuid, [anno.rel1Annotation.uuid, anno.rel2Annotation.uuid])\r\n      && anyOf(this.rel2Annotation.uuid, [anno.rel1Annotation.uuid, anno.rel2Annotation.uuid])\r\n\r\n    return isSame\r\n  }\r\n\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/annotation/relation.js\n// module id = 51\n// module chunks = 2","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/events/events.js\n// module id = 54\n// module chunks = 2","\r\nexport const BORDER_COLOR = '#00BFFF'\r\n\r\n/**\r\n * Adjust scale from normalized scale (100%) to rendered scale.\r\n *\r\n * @param {SVGElement} svg The SVG to gather metadata from\r\n * @param {Object} rect A map of numeric values to scale\r\n * @return {Object} A copy of `rect` with values scaled up\r\n */\r\nexport function scaleUp (svg, rect) {\r\n\r\n  if (arguments.length === 1) {\r\n    rect = svg\r\n  }\r\n\r\n  let result = {}\r\n  const viewport = window.PDFView.pdfViewer.getPageView(0).viewport\r\n\r\n  Object.keys(rect).forEach((key) => {\r\n    result[key] = rect[key] * viewport.scale\r\n  })\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * Adjust scale from rendered scale to a normalized scale (100%).\r\n *\r\n * @param {Object} rect A map of numeric values to scale\r\n * @return {Object} A copy of `rect` with values scaled down\r\n */\r\nexport function scaleDown (rect) {\r\n\r\n  // TODO for old style:  scaleDown(svg, rect)\r\n  if (arguments.length === 2) {\r\n    rect = arguments[1]\r\n  }\r\n\r\n  let result = {}\r\n  const viewport = window.PDFView.pdfViewer.getPageView(0).viewport\r\n  Object.keys(rect).forEach((key) => {\r\n    result[key] = rect[key] / viewport.scale\r\n  })\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * Disable all text layers.\r\n */\r\nexport function disableTextlayer () {\r\n  $('body').addClass('disable-text-layer')\r\n}\r\n\r\n/**\r\n * Enable all text layers.\r\n */\r\nexport function enableTextlayer () {\r\n  $('body').removeClass('disable-text-layer')\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/UI/utils.js\n// module id = 55\n// module chunks = 2","import { renderRect } from './renderRect'\r\nimport { renderSpan } from './renderSpan'\r\nimport renderText from './renderText'\r\nimport { renderRelation } from './renderRelation'\r\n\r\n/**\r\n * Transform the rotation and scale of a node using SVG's native transform attribute.\r\n *\r\n * @param {Node} node The node to be transformed\r\n * @param {Object} viewport The page's viewport data\r\n * @return {Node}\r\n */\r\nfunction transform (node, viewport) {\r\n  node.style.transform = `scale(${viewport.scale})`\r\n  return node\r\n}\r\n\r\n/**\r\n * Append an annotation as a child of an SVG.\r\n *\r\n * @param {SVGElement} svg The SVG element to append the annotation to\r\n * @param {Object} annotation The annotation definition to render and append\r\n * @param {Object} viewport The page's viewport data\r\n * @return {SVGElement} A node that was created and appended by this function\r\n */\r\nexport default function appendChild (svg, annotation, viewport) {\r\n  // TODO no need third argument(viewport) ?\r\n  if (!viewport) {\r\n    viewport = window.PDFView.pdfViewer.getPageView(0).viewport\r\n  }\r\n\r\n  let child\r\n  switch (annotation.type) {\r\n  case 'rect':\r\n    child = renderRect(annotation, svg)\r\n    break\r\n  case 'span':\r\n    child = renderSpan(annotation, svg)\r\n    break\r\n  case 'textbox':\r\n    child = renderText(annotation, svg)\r\n    break\r\n  case 'relation':\r\n    child = renderRelation(annotation, svg)\r\n    break\r\n  }\r\n\r\n  // If no type was provided for an annotation it will result in node being null.\r\n  // Skip appending/transforming if node doesn't exist.\r\n  if (child) {\r\n\r\n    let elm = transform(child, viewport)\r\n\r\n    if (annotation.type === 'textbox') {\r\n      svg.appendChild(elm)\r\n\r\n      // `text` show above other type elements.\r\n    } else {\r\n      svg.append(elm)\r\n    }\r\n  }\r\n  return child\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/render/appendChild.js\n// module id = 56\n// module chunks = 2","/**\r\n * Change color definition style from hex to rgba.\r\n */\r\nexport function hex2rgba (hex, alpha = 1) {\r\n\r\n  // long version\r\n  let r = hex.match(/^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i)\r\n  let c = null\r\n  if (r) {\r\n    c = r.slice(1, 4).map(function (x) { return parseInt(x, 16) })\r\n  }\r\n  // short version\r\n  r = hex.match(/^#([0-9a-f])([0-9a-f])([0-9a-f])$/i)\r\n  if (r) {\r\n    c = r.slice(1, 4).map(function (x) { return 0x11 * parseInt(x, 16) })\r\n  }\r\n  if (!c) {\r\n    return hex\r\n  }\r\n  return `rgba(${c[0]}, ${c[1]}, ${c[2]}, ${alpha})`\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/utils/color.js\n// module id = 57\n// module chunks = 2","let packageJson = require('json-loader!../../../package.json')\r\n/**\r\n * Paper Anno Version.\r\n * This is overwritten at build.\r\n */\r\nexport let ANNO_VERSION = packageJson.version\r\nexport let PDFEXTRACT_VERSION = packageJson.pdfextract.version\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/version.js\n// module id = 58\n// module chunks = 2","const UPPER_REGEX = /[A-Z]/g\r\n\r\n// Don't convert these attributes from camelCase to hyphenated-attributes\r\nconst BLACKLIST = [\r\n  'viewBox'\r\n]\r\n\r\nlet keyCase = (key) => {\r\n  if (BLACKLIST.indexOf(key) === -1) {\r\n    key = key.replace(UPPER_REGEX, match => '-' + match.toLowerCase())\r\n  }\r\n  return key\r\n}\r\n\r\n/**\r\n * Set attributes for a node from a map\r\n *\r\n * @param {Node} node The node to set attributes on\r\n * @param {Object} attributes The map of key/value pairs to use for attributes\r\n */\r\nexport default function setAttributes (node, attributes) {\r\n  Object.keys(attributes).forEach((key) => {\r\n    node.setAttribute(keyCase(key), attributes[key])\r\n  })\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/utils/setAttributes.js\n// module id = 59\n// module chunks = 2","/**\r\n * Dispatch a custom event to `window` object.\r\n */\r\nexport function dispatchWindowEvent (eventName, data) {\r\n  var event = document.createEvent('CustomEvent')\r\n  event.initCustomEvent(eventName, true, true, data)\r\n  window.dispatchEvent(event)\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/utils/event.js\n// module id = 61\n// module chunks = 2","/**\r\n * Enable Text input enable.\r\n */\r\nexport function enable ({ uuid, text, disable = false, autoFocus = false, blurListener = null }) {\r\n  var event = document.createEvent('CustomEvent')\r\n  event.initCustomEvent('enableTextInput', true, true, ...arguments)\r\n  window.dispatchEvent(event)\r\n  console.log('dispatchEvent:', event, arguments[0])\r\n}\r\n\r\n/**\r\n * Disable the text input.\r\n */\r\nexport function disable () {\r\n  var event = document.createEvent('CustomEvent')\r\n  event.initCustomEvent('disappearTextInput', true, true)\r\n  window.dispatchEvent(event)\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/utils/textInput.js\n// module id = 62\n// module chunks = 2","import { uuid } from 'anno-ui/src/utils'\r\nimport AbstractAnnotation from './abstract'\r\nimport { scaleDown, disableTextlayer, enableTextlayer } from '../UI/utils'\r\nimport { convertFromExportY } from '../../../shared/coords'\r\n\r\nlet globalEvent\r\n\r\n/**\r\n * Rect Annotation.\r\n */\r\nexport default class RectAnnotation extends AbstractAnnotation {\r\n\r\n  /**\r\n   * Constructor.\r\n   */\r\n  constructor () {\r\n\r\n    super()\r\n\r\n    globalEvent = window.globalEvent\r\n\r\n    this.uuid     = null\r\n    this.type     = 'rect'\r\n    this.x        = 0\r\n    this.y        = 0\r\n    this.width    = 0\r\n    this.height   = 0\r\n    this.text     = null\r\n    this.color    = null\r\n    this.readOnly = false\r\n    this.$element = this.createDummyElement()\r\n\r\n    globalEvent.on('deleteSelectedAnnotation', this.deleteSelectedAnnotation)\r\n    globalEvent.on('enableViewMode', this.enableViewMode)\r\n  }\r\n\r\n  /**\r\n   * Create an instance from an annotation data.\r\n   */\r\n  static newInstance (annotation) {\r\n    let rect      = new RectAnnotation()\r\n    rect.uuid     = annotation.uuid || uuid()\r\n    rect.x        = annotation.x\r\n    rect.y        = annotation.y\r\n    rect.width    = annotation.width\r\n    rect.height   = annotation.height\r\n    rect.text     = annotation.text\r\n    rect.color    = annotation.color\r\n    rect.readOnly = annotation.readOnly || false\r\n    rect.zIndex   = annotation.zIndex || 10\r\n    return rect\r\n  }\r\n\r\n  /**\r\n   * Create an instance from a TOML object.\r\n   */\r\n  static newInstanceFromTomlObject (tomlObject) {\r\n    let d      = tomlObject\r\n    d.position = d.position.map(parseFloat)\r\n    d.x        = d.position[0]\r\n    d.y        = convertFromExportY(d.page, d.position[1])\r\n    d.width    = d.position[2]\r\n    d.height   = d.position[3]\r\n    d.text     = d.label\r\n    let rect   = RectAnnotation.newInstance(d)\r\n    return rect\r\n  }\r\n\r\n  /**\r\n   * Set a hover event.\r\n   */\r\n  setHoverEvent () {\r\n    this.$element.find('.anno-rect, .anno-knob').hover(\r\n      this.handleHoverInEvent,\r\n      this.handleHoverOutEvent\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Delete the annotation from rendering, a container in window, and a container in localStorage.\r\n   */\r\n  destroy () {\r\n    let promise = super.destroy()\r\n    this.emit('delete')\r\n    window.globalEvent.removeListener('deleteSelectedAnnotation', this.deleteSelectedAnnotation)\r\n    window.globalEvent.removeListener('enableViewMode', this.enableViewMode)\r\n    return promise\r\n  }\r\n\r\n  /**\r\n   * Create an annotation data for save.\r\n   */\r\n  createAnnotation () {\r\n    return {\r\n      uuid      : this.uuid,\r\n      type      : this.type,\r\n      x         : this.x,\r\n      y         : this.y,\r\n      width     : this.width,\r\n      height    : this.height,\r\n      text      : this.text,\r\n      color     : this.color,\r\n      readyOnly : this.readOnly\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete the annotation if selected.\r\n   */\r\n  deleteSelectedAnnotation () {\r\n    super.deleteSelectedAnnotation()\r\n  }\r\n\r\n  /**\r\n   * Get the position for text.\r\n   */\r\n  getTextPosition () {\r\n    return {\r\n      x : this.x + 7,\r\n      y : this.y - 20\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle a selected event on a text.\r\n   */\r\n  handleTextSelected () {\r\n    this.select()\r\n  }\r\n\r\n  /**\r\n   * Handle a deselected event on a text.\r\n   */\r\n  handleTextDeselected () {\r\n    this.deselect()\r\n  }\r\n\r\n  /**\r\n   * Handle a hovein event on a text.\r\n   */\r\n  handleTextHoverIn () {\r\n    this.highlight()\r\n    this.emit('hoverin')\r\n  }\r\n\r\n  /**\r\n   * Handle a hoveout event on a text.\r\n   */\r\n  handleTextHoverOut () {\r\n    this.dehighlight()\r\n    this.emit('hoverout')\r\n  }\r\n\r\n  /**\r\n   * Save a new text.\r\n   */\r\n  handleTextChanged (newText) {\r\n    console.log('rect:handleTextChanged:', newText)\r\n    this.text = newText\r\n    this.save()\r\n  }\r\n\r\n  /**\r\n   * Handle a hoverin event.\r\n   */\r\n  handleHoverInEvent (e) {\r\n    super.handleHoverInEvent(e)\r\n\r\n    let $elm = $(e.currentTarget)\r\n    if ($elm.prop('tagName') === 'circle') {\r\n      this.emit('circlehoverin', this)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle a hoverout event.\r\n   */\r\n  handleHoverOutEvent (e) {\r\n    super.handleHoverOutEvent(e)\r\n\r\n    let $elm = $(e.currentTarget)\r\n    if ($elm.prop('tagName') === 'circle') {\r\n      this.emit('circlehoverout', this)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle a click event.\r\n   */\r\n  handleClickEvent (e) {\r\n    super.handleClickEvent(e)\r\n  }\r\n\r\n  /**\r\n   * Handle a mousedown event.\r\n   */\r\n  handleMouseDownOnRect () {\r\n    console.log('handleMouseDownOnRect')\r\n\r\n    this.originalX = this.x\r\n    this.originalY = this.y\r\n\r\n    document.addEventListener('mousemove', this.handleMouseMoveOnDocument)\r\n    document.addEventListener('mouseup', this.handleMouseUpOnDocument)\r\n\r\n    window.globalEvent.emit('rectmovestart')\r\n\r\n    disableTextlayer()\r\n  }\r\n\r\n  /**\r\n   * Handle a mousemove event.\r\n   */\r\n  handleMouseMoveOnDocument (e) {\r\n\r\n    this._dragging = true\r\n\r\n    if (!this.startX) {\r\n      this.startX = parseInt(e.clientX)\r\n      this.startY = parseInt(e.clientY)\r\n    }\r\n    this.endX = parseInt(e.clientX)\r\n    this.endY = parseInt(e.clientY)\r\n\r\n    let diff = scaleDown({\r\n      x : this.endX - this.startX,\r\n      y : this.endY - this.startY\r\n    })\r\n\r\n    this.x = this.originalX + diff.x\r\n    this.y = this.originalY + diff.y\r\n\r\n    this.render()\r\n\r\n    this.emit('rectmove', this)\r\n  }\r\n\r\n  /**\r\n   * Handle a mouseup event.\r\n   */\r\n  handleMouseUpOnDocument () {\r\n\r\n    if (this._dragging) {\r\n      this._dragging = false\r\n\r\n      this.originalX = null\r\n      this.originalY = null\r\n      this.startX = null\r\n      this.startY = null\r\n      this.endX = null\r\n      this.endY = null\r\n\r\n      this.save()\r\n      this.enableViewMode()\r\n      globalEvent.emit('rectmoveend', this)\r\n    }\r\n\r\n    document.removeEventListener('mousemove', this.handleMouseMoveOnDocument)\r\n    document.removeEventListener('mouseup', this.handleMouseUpOnDocument)\r\n\r\n    if (window.currentType !== 'rect') {\r\n      enableTextlayer()\r\n    }\r\n  }\r\n\r\n  enableDragAction () {\r\n    this.$element.find('.anno-rect, circle')\r\n      .off('mousedown', this.handleMouseDownOnRect)\r\n      .on('mousedown', this.handleMouseDownOnRect)\r\n  }\r\n\r\n  disableDragAction () {\r\n    this.$element.find('.anno-rect, circle')\r\n      .off('mousedown', this.handleMouseDownOnRect)\r\n  }\r\n\r\n  /**\r\n   * Enable view mode.\r\n   */\r\n  enableViewMode () {\r\n    super.enableViewMode()\r\n    if (!this.readOnly) {\r\n      this.$element.find('.anno-rect, .anno-knob').on('click', this.handleClickEvent)\r\n      this.enableDragAction()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disable view mode.\r\n   */\r\n  disableViewMode () {\r\n    super.disableViewMode()\r\n    this.$element.find('.anno-rect, .anno-knob').off('click')\r\n    this.disableDragAction()\r\n  }\r\n\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/annotation/rect.js\n// module id = 63\n// module chunks = 2","/**\r\n Functions for annotations rendered over a PDF file.\r\n */\r\nrequire('!style-loader!css-loader!./index.css')\r\nimport { dispatchWindowEvent } from '../shared/util'\r\n\r\nimport EventEmitter from 'events'\r\n\r\nwindow.globalEvent = new EventEmitter()\r\n\r\n// This is the entry point of window.xxx.\r\n// (setting from webpack.config.js)\r\nimport PDFAnnoCore from './src/PDFAnnoCore'\r\nexport default PDFAnnoCore\r\n\r\n// Create an annocation container.\r\nimport AnnotationContainer from './src/annotation/container'\r\nwindow.annotationContainer = new AnnotationContainer()\r\n\r\n// Enable a view mode.\r\nPDFAnnoCore.UI.enableViewMode()\r\n\r\n// The event called at page rendered by pdfjs.\r\nwindow.addEventListener('pagerendered', function (ev) {\r\n  console.log('pagerendered:', ev.detail.pageNumber)\r\n\r\n  // No action, if the viewer is closed.\r\n  if (!window.PDFView.pdfViewer.getPageView(0)) {\r\n    return\r\n  }\r\n\r\n  adjustPageGaps()\r\n  renderAnno()\r\n})\r\n\r\n// Adapt to scale change.\r\nwindow.addEventListener('scalechange', () => {\r\n  console.log('scalechange')\r\n  adjustPageGaps()\r\n  removeAnnoLayer()\r\n  renderAnno()\r\n})\r\n\r\nfunction adjustPageGaps () {\r\n  // Issue Fix.\r\n  // Correctly rendering when changing scaling.\r\n  // The margin between pages is fixed(9px), and never be scaled in default,\r\n  // then manually have to change the margin.\r\n  let scale = window.PDFView.pdfViewer.getPageView(0).viewport.scale\r\n  let borderWidth = `${9 * scale}px`\r\n  let marginBottom = `${-9 * scale}px`\r\n  let marginTop = `${1 * scale}px`\r\n  $('.page').css({\r\n    'border-top-width'    : borderWidth,\r\n    'border-bottom-width' : borderWidth,\r\n    marginBottom,\r\n    marginTop\r\n  })\r\n}\r\n\r\n/*\r\n * Remove the annotation layer and the temporary rendering layer.\r\n */\r\nfunction removeAnnoLayer () {\r\n  // TODO Remove #annoLayer.\r\n  $('#annoLayer, #annoLayer2').remove()\r\n}\r\n\r\n/*\r\n * Render annotations saved in the storage.\r\n */\r\nfunction renderAnno () {\r\n\r\n  // No action, if the viewer is closed.\r\n  if (!window.PDFView.pdfViewer.getPageView(0)) {\r\n    return\r\n  }\r\n\r\n  // TODO make it a global const.\r\n  const svgLayerId = 'annoLayer'\r\n  const annoLayer2Id = 'annoLayer2'\r\n\r\n  // Check already exists.\r\n  if ($('#' + svgLayerId).length > 0) {\r\n    return\r\n  }\r\n  if ($('#' + annoLayer2Id).length > 0) {\r\n    return\r\n  }\r\n\r\n  let leftMargin = ($('#viewer').width() - $('.page').width()) / 2\r\n\r\n  // At window.width < page.width.\r\n  if (leftMargin < 0) {\r\n    leftMargin = 9\r\n  }\r\n\r\n  let height = $('#viewer').height()\r\n\r\n  let width = $('.page').width()\r\n\r\n  // TODO no need ?\r\n  // Add an annotation layer.\r\n  let $annoLayer = $(`<svg id=\"${svgLayerId}\" class=\"${svgLayerId}\"/>`).css({   // TODO CSSClass.\r\n    position   : 'absolute',\r\n    top        : '0px',\r\n    left       : `${leftMargin}px`,\r\n    width      : `${width}px`,\r\n    height     : `${height}px`,\r\n    visibility : 'hidden',\r\n    'z-index'  : 2\r\n  })\r\n  // Add an annotation layer.\r\n  let $annoLayer2 = $(`<div id=\"${annoLayer2Id}\"/>`).addClass('annoLayer').css({   // TODO CSSClass.\r\n    position   : 'absolute',\r\n    top        : '0px',\r\n    left       : `${leftMargin}px`,\r\n    width      : `${width}px`,\r\n    height     : `${height}px`,\r\n    visibility : 'hidden',\r\n    'z-index'  : 2\r\n  })\r\n\r\n  $('#viewer').css({\r\n    position : 'relative'  // TODO css.\r\n  }).append($annoLayer).append($annoLayer2)\r\n\r\n  renderAnnotations()\r\n}\r\n\r\n/**\r\n * Render all annotations.\r\n */\r\nfunction renderAnnotations () {\r\n  const annotations = window.annotationContainer.getAllAnnotations()\r\n  if (annotations.length === 0) {\r\n    return\r\n  }\r\n  annotations.forEach(a => {\r\n    a.render()\r\n    a.enableViewMode()\r\n  })\r\n  dispatchWindowEvent('annotationrendered')\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/index.js\n// module id = 70\n// module chunks = 2","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../node_modules/css-loader/index.js!./index.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../node_modules/css-loader/index.js!./index.css\", function() {\n\t\t\tvar newContent = require(\"!!../../node_modules/css-loader/index.js!./index.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/style-loader!./node_modules/css-loader!./src/core/index.css\n// module id = 71\n// module chunks = 2","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"@charset \\\"utf-8\\\";\\r\\n\\r\\n/*\\r\\n *  Search UI.\\r\\n */\\r\\n.pdfanno-search-result {\\r\\n    position: absolute;\\r\\n    background-color: rgba(0, 255, 0, 0.7)\\r\\n}\\r\\n.pdfanno-search-result--highlight {\\r\\n    background-color: rgba(255, 0, 0, 0.7)\\r\\n}\\r\\n\\r\\n/*\\r\\n * Text Layer.\\r\\n */\\r\\n.pdfanno-text-layer {\\r\\n    position: absolute;\\r\\n    text-align: center;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Annotation Layer.\\r\\n */\\r\\n.annoLayer > * {\\r\\n  opacity: 0.5;\\r\\n}\\r\\n.annoLayer > *.\\\\--hover,\\r\\n.annoLayer > *.\\\\--selected {\\r\\n  opacity: 1;\\r\\n}\\r\\n\\r\\n/**\\r\\n    Annotation Knob for control.\\r\\n*/\\r\\n.anno-knob {\\r\\n    position: absolute;\\r\\n    background-color: blue;\\r\\n    border-radius: 50%;\\r\\n    transition: 0.2s;\\r\\n    transform-origin: center center;\\r\\n}\\r\\n.\\\\--hover .anno-knob,\\r\\n.\\\\--selected .anno-knob {\\r\\n  box-shadow: rgba(113,135,164,.2) 1px 1px 1px;\\r\\n  transform: scale(2);\\r\\n}\\r\\n.anno-knob.is-readonly {\\r\\n    border-radius: 0;\\r\\n    transform: rotate(45deg) scale(0.7);\\r\\n}\\r\\n.\\\\--hover .anno-knob.is-readonly,\\r\\n.\\\\--selected .anno-knob.is-readonly {\\r\\n  transform: rotate(45deg) scale(1.4);\\r\\n}\\r\\n\\r\\n/*\\r\\n * Span Annotation.\\r\\n */\\r\\n.anno-span {\\r\\n    position: absolute;\\r\\n    top: 0;\\r\\n    left: 0;\\r\\n    visibility: visible;\\r\\n}\\r\\n.anno-span__area {\\r\\n    position: absolute;\\r\\n    border: 1px solid black;\\r\\n}\\r\\n.\\\\--hover .anno-span__area,\\r\\n.\\\\--selected .anno-span__area {\\r\\n  border: 1px dashed black !important;\\r\\n  box-sizing: border-box;\\r\\n}\\r\\n.anno-span__area.no-border,\\r\\n.\\\\--hover .anno-span__area.no-border,\\r\\n.\\\\--selected .anno-span__area.no-border {\\r\\n  border-width: 0 !important;\\r\\n}\\r\\n.anno-span__border {\\r\\n  position: absolute;\\r\\n  /*\\r\\n  #135 Change the style of Reference Anno\\r\\n  border-bottom-width: 1px;\\r\\n  border-bottom-style: solid;\\r\\n  */\\r\\n  border: 1px solid black;\\r\\n}\\r\\n\\r\\n/*TODO Relation*/\\r\\n\\r\\n/**\\r\\n  Relation Annotation.\\r\\n*/\\r\\n.\\\\--hover .anno-relation,\\r\\n.\\\\--selected .anno-relation {\\r\\n  stroke-width: 2px;\\r\\n}\\r\\n.anno-relation-outline {\\r\\n  fill: none;\\r\\n  visibility: hidden;\\r\\n}\\r\\n.\\\\--selected .anno-relation-outline {\\r\\n  visibility: visible;\\r\\n  stroke: black;\\r\\n  stroke-width: 3px;\\r\\n  pointer-events: stroke;\\r\\n  stroke-dasharray: 5;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Span Annotation.\\r\\n */\\r\\n.anno-span rect {\\r\\n    /* Enable the hover event on circles and text even if they are overwraped other spans. */\\r\\n    pointer-events: none;\\r\\n}\\r\\n\\r\\n/**\\r\\n  Rect Annotation.\\r\\n*/\\r\\n.anno-rect-base {\\r\\n    position: absolute;\\r\\n    top: 0;\\r\\n    left: 0;\\r\\n    visibility: visible;\\r\\n}\\r\\n.anno-rect {\\r\\n    position: absolute;\\r\\n}\\r\\n.\\\\--hover .anno-rect {\\r\\n  box-shadow: 0 0 0 1px #ccc inset;\\r\\n  stroke: #ccc;\\r\\n  stroke-width: 0.75px;\\r\\n}\\r\\n.\\\\--selected .anno-rect {\\r\\n  stroke: black;\\r\\n  stroke-width: 0.5px;\\r\\n  stroke-dasharray: 3;\\r\\n}\\r\\n\\r\\n/**\\r\\n Disable text layers.\\r\\n*/\\r\\nbody.disable-text-layer .textLayer {\\r\\n    display: none;\\r\\n}\\r\\n\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader!./src/core/index.css\n// module id = 72\n// module chunks = 2","// import render from './render'\r\nimport UI from './UI'\r\nimport RectAnnotation from './annotation/rect'\r\nimport SpanAnnotation from './annotation/span'\r\nimport RelationAnnotation from './annotation/relation'\r\n\r\nexport default {\r\n\r\n  /**\r\n   * UI is a helper for instrumenting UI interactions for creating,\r\n   * editing, and deleting annotations in the browser.\r\n   */\r\n  UI,\r\n\r\n  /**\r\n   * RectAnnotation Class.\r\n   */\r\n  RectAnnotation,\r\n\r\n  /**\r\n   * SpanAnnotation Class.\r\n   */\r\n  SpanAnnotation,\r\n\r\n  /**\r\n   * RelationAnnotation Class.\r\n   */\r\n  RelationAnnotation\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/PDFAnnoCore.js\n// module id = 73\n// module chunks = 2","import { createSpan, getRectangles } from './span'\r\nimport { createRelation } from './relation'\r\nimport { enableViewMode } from './view'\r\n\r\nexport default {\r\n  createSpan,\r\n  getRectangles,\r\n  createRelation,\r\n  enableViewMode\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/UI/index.js\n// module id = 74\n// module chunks = 2","import { scaleDown } from './utils'\r\nimport SpanAnnotation from '../annotation/span'\r\nimport * as textInput from '../utils/textInput'\r\n\r\nfunction scale () {\r\n  return window.PDFView.pdfViewer.getPageView(0).viewport.scale\r\n}\r\n\r\n/**\r\n * Merge user selections.\r\n */\r\nfunction mergeRects (rects) {\r\n\r\n  // Remove null.\r\n  rects = rects.filter(rect => rect)\r\n\r\n  // Normalize.\r\n  rects = rects.map(rect => {\r\n    rect.top = rect.top || rect.y\r\n    rect.left = rect.left || rect.x\r\n    rect.right = rect.right || (rect.x + rect.w)\r\n    rect.bottom = rect.bottom || (rect.y + rect.h)\r\n    return rect\r\n  })\r\n\r\n  // a virtical margin of error.\r\n  const error = 5 * scale()\r\n\r\n  let tmp = convertToObject(rects[0])\r\n  let newRects = [tmp]\r\n  for (let i = 1; i < rects.length; i++) {\r\n\r\n    // Same line -> Merge rects.\r\n    if (withinMargin(rects[i].top, tmp.top, error)) {\r\n      tmp.top    = Math.min(tmp.top, rects[i].top)\r\n      tmp.left   = Math.min(tmp.left, rects[i].left)\r\n      tmp.right  = Math.max(tmp.right, rects[i].right)\r\n      tmp.bottom = Math.max(tmp.bottom, rects[i].bottom)\r\n      tmp.x      = tmp.left\r\n      tmp.y      = tmp.top\r\n      tmp.width  = tmp.right - tmp.left\r\n      tmp.height = tmp.bottom - tmp.top\r\n\r\n      // New line -> Create a new rect.\r\n    } else {\r\n      tmp = convertToObject(rects[i])\r\n      newRects.push(tmp)\r\n    }\r\n  }\r\n\r\n  return newRects\r\n}\r\n\r\n/**\r\n * Convert a DOMList to a javascript plan object.\r\n */\r\nfunction convertToObject (rect) {\r\n  return {\r\n    top    : rect.top,\r\n    left   : rect.left,\r\n    right  : rect.right,\r\n    bottom : rect.bottom,\r\n    x      : rect.x,\r\n    y      : rect.y,\r\n    width  : rect.width,\r\n    height : rect.height\r\n  }\r\n}\r\n\r\n/**\r\n * Check the value(x) within the range.\r\n */\r\nfunction withinMargin (x, base, margin) {\r\n  return (base - margin) <= x && x <= (base + margin)\r\n}\r\n\r\n/**\r\n * Save a rect annotation.\r\n */\r\nfunction saveSpan ({\r\n  text = '',\r\n  rects = [],\r\n  textRange = [],\r\n  selectedText = '',\r\n  zIndex = 10,\r\n  color = '#ffff00',\r\n  page = 1,\r\n  save = true,\r\n  focusToLabel = true,\r\n  knob = true,\r\n  border = true\r\n}) {\r\n\r\n  if (!rects) {\r\n    return\r\n  }\r\n\r\n  let annotation = {\r\n    rectangles : rects,\r\n    selectedText,\r\n    text,\r\n    textRange,\r\n    zIndex,\r\n    color,\r\n    page,\r\n    knob,\r\n    border\r\n  }\r\n\r\n  // Save.\r\n  let spanAnnotation = SpanAnnotation.newInstance(annotation)\r\n  if (save) {\r\n    spanAnnotation.save()\r\n  }\r\n\r\n  // Render.\r\n  spanAnnotation.render()\r\n\r\n  // Select.\r\n  spanAnnotation.select()\r\n\r\n  // Enable label input.\r\n  if (focusToLabel) {\r\n    textInput.enable({ uuid : spanAnnotation.uuid, autoFocus : true, text })\r\n  }\r\n\r\n  return spanAnnotation\r\n}\r\n\r\n/**\r\n * Get the rect area of User selected.\r\n */\r\nexport function getRectangles () {\r\n\r\n  if (!currentPage || !startPosition || !endPosition) {\r\n    return null\r\n\r\n  } else {\r\n    let targets = findTexts(currentPage, startPosition, endPosition)\r\n    return mergeRects(targets)\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Create a span by current texts selection.\r\n */\r\nexport function createSpan ({ text = null, zIndex = 10, color = null }) {\r\n\r\n  if (!currentPage || !startPosition || !endPosition) {\r\n    return null\r\n\r\n  } else {\r\n\r\n    let targets = findTexts(currentPage, startPosition, endPosition)\r\n    if (targets.length === 0) {\r\n      return null\r\n    }\r\n\r\n    let selectedText = targets.map(t => {\r\n      return t ? t.char : ' '\r\n    }).join('')\r\n\r\n    const mergedRect = mergeRects(targets)\r\n    const annotation = saveSpan({\r\n      rects : mergedRect,\r\n      page  : currentPage,\r\n      text,\r\n      zIndex,\r\n      color,\r\n      textRange: [ startPosition, endPosition ],\r\n      selectedText\r\n    })\r\n\r\n    // Remove user selection.\r\n    if (spanAnnotation) {\r\n      spanAnnotation.destroy()\r\n    }\r\n    startPosition = null\r\n    endPosition = null\r\n    currentPage = null\r\n    spanAnnotation = null\r\n\r\n    return annotation\r\n  }\r\n\r\n}\r\n\r\nwindow.addEventListener('DOMContentLoaded', () => {\r\n\r\n  function setPositions(e) {\r\n\r\n    const canvasElement = e.currentTarget\r\n    const pageElement = canvasElement.parentNode\r\n    const page = parseInt(pageElement.getAttribute('data-page-number'))\r\n    currentPage = page\r\n\r\n    const { top, left } = canvasElement.getBoundingClientRect()\r\n    const x = e.clientX - left\r\n    const y = e.clientY - top\r\n\r\n    // Find the data in pdftxt.\r\n    const item = window.findText(page, scaleDown({ x, y }))\r\n    if (item) {\r\n      if (!startPosition || !endPosition) {\r\n        initPosition = item.position\r\n        startPosition = item.position\r\n        endPosition = item.position\r\n      } else {\r\n        if (item.position < initPosition) {\r\n          startPosition = item.position\r\n          endPosition = initPosition\r\n        } else {\r\n          startPosition = initPosition\r\n          endPosition = item.position\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function makeSelections(e) {\r\n\r\n    setPositions(e)\r\n\r\n    if (spanAnnotation) {\r\n      spanAnnotation.destroy()\r\n      spanAnnotation = null\r\n    }\r\n\r\n    let targets = findTexts(currentPage, startPosition, endPosition)\r\n    if (targets.length > 0) {\r\n      const mergedRect = mergeRects(targets)\r\n      spanAnnotation = saveSpan({\r\n        rects        : mergedRect,\r\n        page         : currentPage,\r\n        save         : false,\r\n        focusToLabel : false,\r\n        color        : '#0f0',\r\n        knob         : false,\r\n        border       : false,\r\n        textRange    : [ startPosition, endPosition ]\r\n      })\r\n      spanAnnotation.disable()\r\n    }\r\n  }\r\n\r\n  const $viewer = $('#viewer')\r\n\r\n  $viewer.on('mousedown', '.canvasWrapper', e => {\r\n    if (otherAnnotationTreating) {\r\n      // Ignore, if other annotation is detected.\r\n      return\r\n    }\r\n    mouseDown = true\r\n    currentPage = null\r\n    initPosition = null\r\n    startPosition = null\r\n    endPosition = null\r\n    if (spanAnnotation) {\r\n      spanAnnotation.destroy()\r\n      spanAnnotation = null\r\n    }\r\n    makeSelections(e)\r\n  })\r\n  $viewer.on('mousemove', '.canvasWrapper', e => {\r\n    if (mouseDown) {\r\n      makeSelections(e)\r\n    }\r\n  })\r\n  $viewer.on('mouseup', '.canvasWrapper', e => {\r\n    if (mouseDown) {\r\n      makeSelections(e)\r\n      if (spanAnnotation) {\r\n        spanAnnotation.deselect()\r\n      }\r\n    }\r\n    mouseDown = false\r\n  })\r\n\r\n  let otherAnnotationTreating = false\r\n  window.addEventListener('annotationHoverIn', () => {\r\n    otherAnnotationTreating = true\r\n  })\r\n  window.addEventListener('annotationHoverOut', () => {\r\n    otherAnnotationTreating = false\r\n  })\r\n  window.addEventListener('annotationDeleted', () => {\r\n    otherAnnotationTreating = false\r\n  })\r\n\r\n})\r\n\r\nlet mouseDown = false\r\nlet initPosition = null\r\nlet startPosition = null\r\nlet endPosition = null\r\nlet currentPage = null\r\nlet spanAnnotation = null\r\n\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/UI/span.js\n// module id = 75\n// module chunks = 2","import { renderKnob } from './renderKnob'\r\nimport { hex2rgba } from '../utils/color'\r\n\r\n/**\r\n * Create a rect annotation.\r\n * @param {RectAnnotation} a - rect annotation.\r\n */\r\nexport function renderRect (a) {\r\n\r\n  let color = a.color || '#FF0'\r\n\r\n  const $base = $('<div class=\"anno-rect-base\"/>')\r\n\r\n  $base.append($('<div class=\"anno-rect\"/>').css({\r\n    top             : `${a.y}px`,\r\n    left            : `${a.x}px`,\r\n    width           : `${a.width}px`,\r\n    height          : `${a.height}px`,\r\n    border          : `1px solid ${color}`,\r\n    backgroundColor : a.readOnly ? 'none' : hex2rgba(color, 0.3)\r\n  }))\r\n\r\n  $base.append(renderKnob(a))\r\n\r\n  return $base[0]\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/render/renderRect.js\n// module id = 76\n// module chunks = 2","import { renderKnob } from './renderKnob'\nimport { hex2rgba } from '../utils/color'\nimport { ANNO_VERSION } from '../version'\n\nconsole.log('ANNO_VERSION:', ANNO_VERSION)\n\n/**\n * Create a Span element.\n * @param {SpanAnnotation} a - span annotation.\n * @return {HTMLElement} a html element describing a span annotation.\n */\nexport function renderSpan (a) {\n\n  const readOnly = a.readOnly\n\n  const color = a.color || '#FF0'\n\n  const $base = $('<div class=\"anno-span\"/>')\n    .css('zIndex', a.zIndex || 10)\n\n  if (!a.page) {\n    if (a.rectangles.length > 0) {\n      a.page = a.rectangles[0].page\n    }\n  }\n\n  let paddingTop = 9\n  const pageView = window.PDFView.pdfViewer.getPageView(0)\n  const viewport = pageView.viewport\n  const scale = viewport.scale\n  // const viewBox = viewport.viewBox\n  // let pageHeight = viewBox[3] - viewBox[1]\n  let merginBetweenPages =  1\n\n  // #139 correct the absolute position of annotation\n  // let pageTopY = paddingTop + (paddingTop + pageHeight + merginBetweenPages) * (a.page - 1)\n  // let pageTopY = $('#pageContainer' + a.page).position().top / scale + paddingTop\n  let pageTopY = $('#pageContainer' + a.page).position().top / scale + paddingTop + merginBetweenPages\n\n  // console.log('renderSpan()', scale, pageTopY, a.rectangles)\n\n  const rectangles = a.rectangles.map(r => {\n    return {\n      x      : r.x || r.left,\n      y      : (r.y || r.top) + pageTopY,\n      width  : r.width || r.right - r.left,\n      height : r.height || r.bottom - r.top\n    }\n  }).filter(r => r.width > 0 && r.height > 0 && r.x > -1 && r.y > -1)\n\n  rectangles.forEach(r => {\n    $base.append(createRect(a, r, color, readOnly))\n  })\n\n  if (a.knob) {\n    $base.append(renderKnob({\n      x : rectangles[0].x,\n      y : rectangles[0].y,\n      readOnly\n    }))\n  }\n\n  return $base[0]\n}\n\nfunction createRect (a, r, color, readOnly) {\n\n  /*\n  // #135 Change the style of Reference Anno\n  if (readOnly) {\n    return $('<div class=\"anno-span__border\"/>').css({\n      top         : r.y + 'px',\n      left        : r.x + 'px',\n      width       : r.width + 'px',\n      height      : r.height + 'px',\n      borderColor : color\n    })\n\n  } else {\n\n    const rgba = hex2rgba(color, 0.4)\n    const borderCss = (a.border === false ? 'no-border' : '')\n\n    return $(`<div class=\"anno-span__area ${borderCss}\"/>`).css({\n      top             : r.y + 'px',\n      left            : r.x + 'px',\n      width           : r.width + 'px',\n      height          : r.height + 'px',\n      backgroundColor : rgba,\n      borderColor     : color\n    })\n  }\n  */\n\n  let className = readOnly ? 'anno-span__border' : 'anno-span__area'\n  if (a.border === false) {\n    className += ' no-border'\n  }\n\n  return $(`<div class=\"${className}\"/>`).css({\n    top             : r.y + 'px',\n    left            : r.x + 'px',\n    width           : r.width + 'px',\n    height          : r.height + 'px',\n    backgroundColor : hex2rgba(color, 0.4),\n    borderColor     : color\n  })\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/render/renderSpan.js\n// module id = 77\n// module chunks = 2","module.exports = {\"name\":\"pdfanno\",\"version\":\"0.4.1-dev\",\"description\":\"\",\"main\":\"index.js\",\"scripts\":{\"_prepare\":\"gulp prepare\",\"start\":\"concurrently --kill-others \\\"npm run server:dev\\\" \\\"npm run front:dev\\\"\",\"front:sw\":\"gulp build-sw\",\"front:sw:watch\":\"gulp watch-sw\",\"front:dev\":\"concurrently --kill-others \\\"npm run _prepare && npm run front:sw && webpack-dev-server --inline\\\" \\\"npm run front:sw:watch\\\"\",\"front:publish:latest\":\"npm run _prepare && cross-env BUILD_TARGET=latest npm run front:sw && cross-env NODE_ENV=production SERVER_PATH=latest webpack && gulp publish_latest\",\"front:publish:stable\":\"npm run _prepare && cross-env BUILD_TARGET=stable  npm run front:sw && cross-env NODE_ENV=production SERVER_PATH=0.3.1  webpack && gulp publish_stable\",\"server:latest\":\"cross-env NODE_ENV=production NODE_PORT=1001 node server/server.js\",\"server:stable\":\"cross-env NODE_ENV=production NODE_PORT=1000 node server/server.js\",\"server:dev\":\"cross-env NODE_PORT=3000 ./node_modules/.bin/node-dev server/server.js\"},\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/paperai/pdfanno\"},\"author\":\"hshindo, yoheiMune\",\"license\":\"MIT\",\"bugs\":{\"url\":\"https://github.com/paperai/pdfanno/issues\"},\"homepage\":\"https://github.com/paperai/pdfanno#readme\",\"pdfextract\":{\"version\":\"0.2.3\",\"url\":\"https://github.com/paperai/pdfextract/releases/download/v0.2.3/pdfextract-0.2.3.jar\"},\"devDependencies\":{\"babel-cli\":\"^6.26.0\",\"babel-core\":\"^6.26.0\",\"babel-eslint\":\"^7.2.3\",\"babel-helpers\":\"^6.24.1\",\"babel-loader\":\"6.2.4\",\"babel-messages\":\"^6.23.0\",\"babel-minify-webpack-plugin\":\"^0.3.0\",\"babel-plugin-add-module-exports\":\"^0.2.1\",\"babel-preset-es2015\":\"^6.24.1\",\"babel-preset-stage-1\":\"^6.24.1\",\"concurrently\":\"^3.5.1\",\"copy\":\"^0.3.0\",\"cpr\":\"^2.2.0\",\"cross-env\":\"^5.0.5\",\"css-loader\":\"^0.25.0\",\"deep-assign\":\"^2.0.0\",\"eslint\":\"^3.19.0\",\"eslint-config-standard\":\"^6.2.1\",\"eslint-friendly-formatter\":\"^2.0.7\",\"eslint-loader\":\"^1.7.1\",\"eslint-plugin-html\":\"^2.0.0\",\"eslint-plugin-promise\":\"^3.5.0\",\"eslint-plugin-standard\":\"^2.3.1\",\"file-loader\":\"^0.9.0\",\"fs-extra\":\"^1.0.0\",\"fuse.js\":\"^3.1.0\",\"gulp\":\"^3.9.1\",\"gulp-clean-css\":\"^3.9.3\",\"gulp-cli\":\"^1.4.0\",\"gulp-replace\":\"^0.6.1\",\"gulp-sourcemaps\":\"^2.6.4\",\"gulp-uglify-es\":\"^1.0.1\",\"gulp-util\":\"^3.0.8\",\"node-dev\":\"^3.1.3\",\"run-sequence\":\"^2.2.1\",\"style-loader\":\"^0.13.2\",\"vinyl-source-stream\":\"^1.1.0\",\"webpack\":\"3.0.0\",\"webpack-dev-server\":\"^1.16.5\"},\"dependencies\":{\"anno-ui\":\"github:paperai/anno-ui#master\",\"axios\":\"^0.15.2\",\"body-parser\":\"^1.17.2\",\"express\":\"^4.15.4\",\"gulp-htmlmin\":\"^4.0.0\",\"json-loader\":\"^0.5.7\",\"mkdirp\":\"^0.5.1\",\"mkdirp-promise\":\"^5.0.1\",\"multer\":\"^1.3.0\",\"request\":\"^2.81.0\",\"request-promise\":\"^4.2.2\",\"requirejs\":\"^2.3.5\",\"socket.io\":\"^2.0.4\",\"toml\":\"github:yoheiMune/toml-node\",\"urijs\":\"^1.19.0\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/json-loader!./package.json\n// module id = 78\n// module chunks = 2","// TODO no need this file ?\r\nimport setAttributes from '../utils/setAttributes'\r\n\r\n/**\r\n * Default font size for Text.\r\n */\r\nconst DEFAULT_FONT_SIZE = 9.5\r\n\r\n/**\r\n * Calculate boundingClientRect that is needed for rendering text.\r\n *\r\n * @param {String} text - A text to be renderd.\r\n * @param {SVGElement} svg - svgHTMLElement to be used for rendering text.\r\n * @return {Object} A boundingBox of text element.\r\n */\r\nfunction getRect (text, svg) {\r\n  svg.appendChild(text)\r\n  let rect = text.getBoundingClientRect()\r\n  text.parentNode.removeChild(text)\r\n  return rect\r\n}\r\n\r\n/**\r\n * Create SVGTextElement from an annotation definition.\r\n * This is used for anntations of type `textbox`.\r\n *\r\n * @param {Object} a The annotation definition\r\n * @return {SVGTextElement} A text to be rendered\r\n */\r\nexport default function renderText (a, svg) {\r\n  // Text.\r\n  let text = document.createElementNS('http://www.w3.org/2000/svg', 'text')\r\n  setAttributes(text, {\r\n    x        : a.x,\r\n    y        : a.y + parseInt(DEFAULT_FONT_SIZE, 10),\r\n    fill     : a.color || '#F00',\r\n    fontSize : DEFAULT_FONT_SIZE\r\n  })\r\n  text.innerHTML = a.content || a.text\r\n\r\n  // Background.\r\n  let box = document.createElementNS('http://www.w3.org/2000/svg', 'rect')\r\n  let rect = getRect(text, svg)\r\n  setAttributes(box, {\r\n    x      : a.x - 1,\r\n    y      : a.y,\r\n    width  : rect.width,\r\n    height : rect.height,\r\n    fill   : '#FFFFFF',\r\n    class  : 'anno-text'\r\n  })\r\n\r\n  // Group.\r\n  let group = document.createElementNS('http://www.w3.org/2000/svg', 'g')\r\n  group.classList.add('anno-text-group')\r\n  group.setAttribute('read-only', a.readOnly === true)\r\n  group.setAttribute('data-parent-id', a.parentId)\r\n  group.style.visibility = 'visible'\r\n  group.appendChild(box)\r\n  group.appendChild(text)\r\n\r\n  return group\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/render/renderText.js\n// module id = 79\n// module chunks = 2","import setAttributes from '../utils/setAttributes'\r\nimport { DEFAULT_RADIUS } from './renderKnob'\r\nimport { findBezierControlPoint } from '../utils/relation.js'\r\n\r\n/**\r\n * Create a RELATION annotation.\r\n *\r\n * @param {RelationAnnotation} a - The annotation definition\r\n * @return {SVGGElement} A group of a relation to be rendered\r\n */\r\nexport function renderRelation (a) {\r\n\r\n  a.color = a.color || '#F00'\r\n\r\n  // Adjust the start/end points.\r\n  let theta = Math.atan((a.y1 - a.y2) / (a.x1 - a.x2))\r\n  let sign = (a.x1 < a.x2 ? 1 : -1)\r\n  a.x1 += DEFAULT_RADIUS * Math.cos(theta) * sign\r\n  a.x2 -= DEFAULT_RADIUS * Math.cos(theta) * sign\r\n  a.y1 += DEFAULT_RADIUS * Math.sin(theta) * sign\r\n  a.y2 -= DEFAULT_RADIUS * Math.sin(theta) * sign\r\n\r\n  let top    = Math.min(a.y1, a.y2)\r\n  let left   = Math.min(a.x1, a.x2)\r\n  let width  = Math.abs(a.x1 - a.x2)\r\n  let height = Math.abs(a.y1 - a.y2)\r\n\r\n  const [ $svg, margin ] = createSVGElement(top, left, width, height)\r\n\r\n  // Transform coords.\r\n  a.x1 = a.x1 - left + margin\r\n  a.x2 = a.x2 - left + margin\r\n  a.y1 = a.y1 - top + margin\r\n  a.y2 = a.y2 - top + margin\r\n\r\n  // <svg viewBox=\"0 0 200 200\">\r\n  //     <marker id=\"m_ar\" viewBox=\"0 0 10 10\" refX=\"5\" refY=\"5\" markerUnits=\"strokeWidth\" preserveAspectRatio=\"none\" markerWidth=\"2\" markerHeight=\"3\" orient=\"auto-start-reverse\">\r\n  //         <polygon points=\"0,0 0,10 10,5\" fill=\"red\" id=\"ms\"/>\r\n  //     </marker>\r\n  //     <path d=\"M50,50 h100\" fill=\"none\" stroke=\"black\" stroke-width=\"10\" marker-start=\"url(#m_ar)\" marker-end=\"url(#m_ar)\"/>\r\n  // </svg>\r\n\r\n  let group = document.createElementNS('http://www.w3.org/2000/svg', 'g')\r\n  setAttributes(group, {\r\n    fill   : a.color,\r\n    stroke : a.color\r\n  })\r\n  group.style.visibility = 'visible'\r\n  group.setAttribute('read-only', a.readOnly === true)\r\n\r\n  $svg[0].appendChild(group)\r\n\r\n  const markerId = 'relationhead' + a.color.replace('#', '')\r\n\r\n  if (!document.querySelector('#' + markerId)) {\r\n    let marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker')\r\n    setAttributes(marker, {\r\n      viewBox : '0 0 10 10',\r\n      // markerWidth  : 2,\r\n      // markerHeight : 3,\r\n      fill    : a.color,\r\n      id      : markerId,\r\n      orient  : 'auto-start-reverse'\r\n    })\r\n    marker.setAttribute('preserveAspectRatio', 'none')\r\n    marker.setAttribute('markerWidth', 5)\r\n    marker.setAttribute('markerHeight', 5)\r\n    marker.setAttribute('refX', 5)\r\n    marker.setAttribute('refY', 5)\r\n    group.appendChild(marker)\r\n\r\n    let polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon')\r\n    setAttributes(polygon, {\r\n      points : '0,0 0,10 10,5'\r\n    })\r\n    marker.appendChild(polygon)\r\n  }\r\n\r\n  // Find Control points.\r\n  let control = findBezierControlPoint(a.x1, a.y1, a.x2, a.y2)\r\n\r\n  // Create Outline.\r\n  let outline = document.createElementNS('http://www.w3.org/2000/svg', 'path')\r\n  setAttributes(outline, {\r\n    d     : `M ${a.x1} ${a.y1} Q ${control.x} ${control.y} ${a.x2} ${a.y2}`,\r\n    class : 'anno-relation-outline'\r\n  })\r\n  group.appendChild(outline)\r\n\r\n  /*\r\n      <path d=\"M 25 25 Q 175 25 175 175\" stroke=\"blue\" fill=\"none\"/>\r\n  */\r\n  let relation = document.createElementNS('http://www.w3.org/2000/svg', 'path')\r\n  setAttributes(relation, {\r\n    d           : `M ${a.x1} ${a.y1} Q ${control.x} ${control.y} ${a.x2} ${a.y2}`,\r\n    stroke      : a.color,\r\n    strokeWidth : 1,\r\n    fill        : 'none',\r\n    class       : 'anno-relation'\r\n  })\r\n\r\n  // Triangle for the end point.\r\n  if (a.direction === 'one-way' || a.direction === 'two-way') {\r\n    relation.setAttribute('marker-end', `url(#${markerId})`)\r\n  }\r\n\r\n  // Triangle for the start point.\r\n  if (a.direction === 'two-way') {\r\n    relation.setAttribute('marker-start', `url(#${markerId})`)\r\n  }\r\n\r\n  group.appendChild(relation)\r\n\r\n  const $base = $('<div/>').css({\r\n    position   : 'absolute',\r\n    top        : 0,\r\n    left       : 0,\r\n    visibility : 'visible'\r\n  }).addClass('anno-relation')\r\n  $base.append($svg)\r\n\r\n  return $base[0]\r\n}\r\n\r\nfunction createSVGElement (top, left, width, height) {\r\n\r\n  // the margin for rendering an arrow curve.\r\n  const margin = 50\r\n\r\n  // Add an annotation layer.\r\n  let $svg = $('<svg class=\"\"/>').css({ // I don't know why, but empty class is need.\r\n    position   : 'absolute',\r\n    top        : `${top - margin}px`,\r\n    left       : `${left - margin}px`,\r\n    width      : `${width + margin * 2}px`,\r\n    height     : `${height + margin * 2}px`,\r\n    visibility : 'hidden',\r\n    'z-index'  : 2\r\n  }).attr({\r\n    x : 0,\r\n    y : 0\r\n  })\r\n\r\n  return [ $svg, margin ]\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/render/renderRelation.js\n// module id = 80\n// module chunks = 2","import * as textInput from '../utils/textInput'\r\nimport RelationAnnotation from '../annotation/relation'\r\n\r\n/**\r\n * Create a new Relation annotation.\r\n */\r\nexport function createRelation ({ type, anno1, anno2, text, color }) {\r\n  // TODO No need?\r\n  // for old style.\r\n  if (arguments.length === 3) {\r\n    type = arguments[0]\r\n    anno1 = arguments[1]\r\n    anno2 = arguments[2]\r\n  }\r\n\r\n  let annotation = new RelationAnnotation()\r\n  annotation.direction = type\r\n  annotation.rel1Annotation = anno1\r\n  annotation.rel2Annotation = anno2\r\n  annotation.text = text\r\n  annotation.color = color\r\n\r\n  annotation.save()\r\n  annotation.render()\r\n\r\n  // TODO Refactoring.\r\n  // TODO .\r\n  // Deselect all.\r\n  window.annotationContainer\r\n    .getSelectedAnnotations()\r\n    .forEach(a => a.deselect())\r\n\r\n  // Select.\r\n  annotation.select()\r\n\r\n  // New type text.\r\n  textInput.enable({ uuid : annotation.uuid, autoFocus : true, text })\r\n\r\n  return annotation\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/UI/relation.js\n// module id = 81\n// module chunks = 2","/**\r\n * Disable the action of pageback, if `DEL` or `BackSpace` button pressed.\r\n */\r\nfunction disablePagebackAction (e) {\r\n  // Allow any keyboard events for <input/>.\r\n  if (e.target.tagName.toLowerCase() === 'input') {\r\n    return\r\n  }\r\n\r\n  // Delete or BackSpace.\r\n  if (e.keyCode === 46 || e.keyCode === 8) {\r\n    e.preventDefault()\r\n\r\n    if (e.type === 'keyup') {\r\n      deleteSelectedAnnotations()\r\n    }\r\n\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Deselect annotations when pages clicked.\r\n */\r\nfunction handlePageClick (e) {\r\n  window.annotationContainer\r\n    .getSelectedAnnotations()\r\n    .forEach(a => a.deselect())\r\n\r\n  var event = document.createEvent('CustomEvent')\r\n  event.initCustomEvent('annotationDeselected', true, true, this)\r\n  window.dispatchEvent(event)\r\n}\r\n\r\n/**\r\n * Delete selected annotations.\r\n */\r\nfunction deleteSelectedAnnotations () {\r\n  window.globalEvent.emit('deleteSelectedAnnotation')\r\n}\r\n\r\n// TODO NO NEED `enableViewMode` event ?\r\n\r\n/**\r\n * Enable view mode.\r\n */\r\nexport function enableViewMode () {\r\n  console.log('view:enableViewMode')\r\n\r\n  document.removeEventListener('keyup', disablePagebackAction)\r\n  document.removeEventListener('keydown', disablePagebackAction)\r\n  document.addEventListener('keyup', disablePagebackAction)\r\n  document.addEventListener('keydown', disablePagebackAction)\r\n\r\n  $(document)\r\n    .off('click', handlePageClick)\r\n    .on('click', '.page', handlePageClick)\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/UI/view.js\n// module id = 82\n// module chunks = 2","import { uuid } from 'anno-ui/src/utils'\r\nimport { ANNO_VERSION, PDFEXTRACT_VERSION } from '../version'\r\nimport { toTomlString, fromTomlString } from '../utils/tomlString'\r\nimport { dispatchWindowEvent } from '../utils/event'\r\nimport { convertToExportY } from '../../../shared/coords'\r\nimport SpanAnnotation from './span'\r\nimport RectAnnotation from './rect'\r\nimport RelationAnnotation from './relation'\r\n\r\n/**\r\n * Annotation Container.\r\n */\r\nexport default class AnnotationContainer {\r\n\r\n  /**\r\n   * Constructor.\r\n   */\r\n  constructor () {\r\n    this.set = new Set()\r\n  }\r\n\r\n  /**\r\n   * Add an annotation to the container.\r\n   */\r\n  add (annotation) {\r\n    this.set.add(annotation)\r\n    dispatchWindowEvent('annotationUpdated')\r\n  }\r\n\r\n  /**\r\n   * Remove the annotation from the container.\r\n   */\r\n  remove (annotation) {\r\n    this.set.delete(annotation)\r\n    dispatchWindowEvent('annotationUpdated')\r\n  }\r\n\r\n  /**\r\n   * Remove all annotations.\r\n   */\r\n  destroy () {\r\n    console.log('AnnotationContainer#destroy')\r\n    this.set.forEach(a => a.destroy())\r\n    this.set = new Set()\r\n  }\r\n\r\n  /**\r\n   * Get all annotations from the container.\r\n   */\r\n  getAllAnnotations () {\r\n    let list = []\r\n    this.set.forEach(a => list.push(a))\r\n    return list\r\n  }\r\n\r\n  /**\r\n   * Get annotations which user select.\r\n   */\r\n  getSelectedAnnotations () {\r\n    return this.getAllAnnotations().filter(a => a.selected)\r\n  }\r\n\r\n  /**\r\n   * Find an annotation by the id which an annotation has.\r\n   */\r\n  findById (uuid) {\r\n    uuid = String(uuid) // `uuid` must be string.\r\n    let annotation = null\r\n    this.set.forEach(a => {\r\n      if (a.uuid === uuid) {\r\n        annotation = a\r\n      }\r\n    })\r\n    return annotation\r\n  }\r\n\r\n  /**\r\n   * Change the annotations color, if the text is the same in an annotation.\r\n   *\r\n   * annoType : span, one-way, two-way, link\r\n   */\r\n  changeColor ({ text, color, uuid, annoType }) {\r\n    console.log('changeColor: ', text, color, uuid)\r\n    if (uuid) {\r\n      const a = this.findById(uuid)\r\n      if (a) {\r\n        a.color = color\r\n        a.render()\r\n        a.enableViewMode()\r\n      }\r\n    } else {\r\n      this.getAllAnnotations()\r\n        .filter(a => a.text === text)\r\n        .filter(a => {\r\n          if (annoType === 'span') {\r\n            return a.type === annoType\r\n          } else if (annoType === 'one-way' || annoType === 'two-way' || annoType === 'link') {\r\n            if (a.type === 'relation' && a.direction === annoType) {\r\n              return true\r\n            }\r\n          }\r\n          return false\r\n        }).forEach(a => {\r\n          a.color = color\r\n          a.render()\r\n          a.enableViewMode()\r\n        })\r\n    }\r\n  }\r\n\r\n  setColor (colorMap) {\r\n    console.log('setColor:', colorMap)\r\n    Object.keys(colorMap).forEach(annoType => {\r\n      if (annoType === 'default') {\r\n        return\r\n      }\r\n      Object.keys(colorMap[annoType]).forEach(text => {\r\n        const color = colorMap[annoType][text]\r\n        this.changeColor({ text, color, annoType })\r\n      })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Export annotations as a TOML string.\r\n   */\r\n  exportData () {\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      let dataExport = {}\r\n\r\n      // Set version.\r\n      dataExport.version = ANNO_VERSION\r\n      dataExport['pdfextract-version'] = PDFEXTRACT_VERSION\r\n\r\n      // Only writable.\r\n      const annos = this.getAllAnnotations().filter(a => !a.readOnly)\r\n\r\n      // Sort by create time.\r\n      // This reason is that a relation need start/end annotation ids which are numbered at export.\r\n      annos.sort((a1, a2) => a1.createdAt - a2.createdAt)\r\n\r\n      // The ID for specifing an annotation on a TOML file.\r\n      // This ID is sequential.\r\n      let id = 0\r\n\r\n      // Create export data.\r\n      annos.forEach(annotation => {\r\n\r\n        // Increment to next.\r\n        id++\r\n\r\n        // Span.\r\n        if (annotation.type === 'span') {\r\n          dataExport[id] = annotation.export()\r\n          // Save temporary for relation.\r\n          annotation.exportId = id\r\n\r\n        // Relation.\r\n        } else if (annotation.type === 'relation') {\r\n          dataExport[id] = annotation.export()\r\n        }\r\n\r\n      })\r\n\r\n      // Remove exportId.\r\n      annos.forEach(annotation => {\r\n        delete annotation.exportId\r\n      })\r\n\r\n      resolve(toTomlString(dataExport))\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Import annotations.\r\n   */\r\n  importAnnotations (data, isPrimary) {\r\n\r\n    const readOnly = !isPrimary\r\n    const colorMap = data.colorMap\r\n\r\n    function getColor (index, type, text) {\r\n      let color = colorMap.default\r\n      if (colorMap[type] && colorMap[type][text]) {\r\n        color = colorMap[type][text]\r\n      }\r\n      return color\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      // Delete old ones.\r\n      this.getAllAnnotations()\r\n        .filter(a => a.readOnly === readOnly)\r\n        .forEach(a => a.destroy())\r\n\r\n      // Add annotations.\r\n      data.annotations.forEach((tomlString, i) => {\r\n\r\n        // Create a object from TOML string.\r\n        let tomlObject = fromTomlString(tomlString)\r\n        if (!tomlObject) {\r\n          return\r\n        }\r\n\r\n        for (const key in tomlObject) {\r\n\r\n          let d = tomlObject[key]\r\n\r\n          // Skip if the content is not object, like version string.\r\n          if (typeof d !== 'object') {\r\n            continue\r\n          }\r\n\r\n          d.uuid = uuid()\r\n          d.readOnly = readOnly\r\n\r\n          if (d.type === 'span') {\r\n\r\n            let span = SpanAnnotation.newInstanceFromTomlObject(d)\r\n            span.color = getColor(i, span.type, span.text)\r\n            span.save()\r\n            span.render()\r\n            span.enableViewMode()\r\n\r\n            // Rect.\r\n          } else if (d.type === 'rect') {\r\n\r\n            let rect = RectAnnotation.newInstanceFromTomlObject(d)\r\n            rect.color = getColor(i, rect.type, rect.text)\r\n            rect.save()\r\n            rect.render()\r\n            rect.enableViewMode()\r\n\r\n            // Relation.\r\n          } else if (d.type === 'relation') {\r\n\r\n            d.rel1 = tomlObject[d.ids[0]].uuid\r\n            d.rel2 = tomlObject[d.ids[1]].uuid\r\n            let relation = RelationAnnotation.newInstanceFromTomlObject(d)\r\n            relation.color = getColor(i, relation.direction, relation.text)\r\n            relation.save()\r\n            relation.render()\r\n            relation.enableViewMode()\r\n\r\n          } else {\r\n            console.log('Unknown: ', key, d)\r\n          }\r\n        }\r\n      })\r\n\r\n      // Done.\r\n      resolve(true)\r\n    })\r\n  }\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/annotation/container.js\n// module id = 83\n// module chunks = 2","/**\r\n * Utilities for TOML format.\r\n */\r\nimport toml from 'toml'\r\n\r\n/**\r\n * Create a TOML String from jsObject.\r\n */\r\nexport function toTomlString (obj, root = true) {\r\n\r\n  let lines = []\r\n\r\n  // `version` and `pdfextract-version` are the first.\r\n  if ('version' in obj) {\r\n    lines.push(`version = \"${obj['version']}\"`)\r\n    lines.push(`pdfextract-version = \"${obj['pdfextract-version']}\"`)\r\n    lines.push('')\r\n    delete obj['version']\r\n    delete obj['pdfextract-version']\r\n  }\r\n\r\n  // #paperanno-ja/issues/38\r\n  // Make all values in `position` as string.\r\n  if ('position' in obj) {\r\n    let position = obj.position\r\n    position = position.map(p => {\r\n      if (typeof p === 'number') {\r\n        return String(p)\r\n      } else {\r\n        return p.map(v => String(v))\r\n      }\r\n    })\r\n    obj.position = position\r\n  }\r\n\r\n  Object.keys(obj).forEach(prop => {\r\n\r\n    let val = obj[prop]\r\n    if (typeof val === 'string') {\r\n      lines.push(`${prop} = \"${val}\"`)\r\n      root && lines.push('')\r\n\r\n    } else if (typeof val === 'number') {\r\n      lines.push(`${prop} = ${val}`)\r\n      root && lines.push('')\r\n\r\n    } else if (isArray(val)) {\r\n      lines.push(`${prop} = ${JSON.stringify(val)}`)\r\n      root && lines.push('')\r\n\r\n    } else if (typeof val === 'object') {\r\n      lines.push(`[${prop}]`)\r\n      lines.push(toTomlString(val, false))\r\n      root && lines.push('')\r\n    }\r\n  })\r\n\r\n  return lines.join('\\n')\r\n}\r\n\r\n/**\r\n * Create a object from TOML string.\r\n */\r\nexport function fromTomlString (tomlString) {\r\n  try {\r\n    return toml.parse(tomlString)\r\n  } catch (e) {\r\n    console.log('ERROR:', e)\r\n    console.log('TOML:\\n', tomlString)\r\n    return null\r\n  }\r\n}\r\n\r\n/**\r\n * Check the val is array.\r\n */\r\nfunction isArray (val) {\r\n  return val && 'length' in val\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/src/utils/tomlString.js\n// module id = 84\n// module chunks = 2"],"sourceRoot":""}